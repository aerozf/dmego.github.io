[{"title":"将WSL2作为生产力工具","date":"2019-12-21T19:46:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.533Z","content":"适用于 Linux 的 Windows 子系统 (WSL) 是 Windows 10新增的功能，使用它可以直接在 Windows 上运行 Linux 命令。而WSL 2 是WSL的一个新版本，它支持适用于 Linux 的 Windows 子系统在 Windows 上运行 ELF64 Linux 二进制文件。 它的主要目标是提高文件系统的性能，并增加系统调用的完全兼容性。WSL 2 使用最新和最高的虚拟化技术在轻型实用程序虚拟机（VM）内部运行 Linux 内核。\n\n 启用并配置 WSL 2\n win 版本要求\nWSL 2 仅在 Windows 10 18917 或更高版本中可用，如果版本太低，可以加入 Windows Insider 升级 Windows ，我们可以在 cmd 中使用 ver 来检查当前 win的版本。\n 启用虚拟机平台可选组件\n在 powerShell 中以管理员身份运行下面命令\n12dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestartdism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n运行完成之后，请重启电脑完成安装.\n 设置WSL发行版\n如果想要将默认的WSL发行版设置成 WSL 2，在 powerShell 中使用下面命令\n1wsl --set-default-version 2\n如果想要设置某一个发行版为WSL2，在 powerShell 中使用下面命令，将 &lt;Distro&gt; 换成你想要设置的发行版即可，例如 Ubuntu-18.04\n1wsl --set-version &lt;Distro&gt; 2\n验证使用的WSL版本\n1wsl -l -v\n 下载安装 Ubuntu-18.04\n在 Windows 应用商店里搜索 Ubuntu-18.04 ，然后下载,下载完成之后打开 Ubuntu-18.04 ，这时会先进行一些初始化安装的设置，然后就会让你设置新的 UNIX用户名和密码，设置完成之后，就进入了 linux 子系统。验证是否是 WSL 2 我们只需要在 powerShell 下输入 wsl -l -v ,输出内容如下，这里 VERSION 为 2 代表启用了 WSL 2\n12NAME                   STATE           VERSION* Ubuntu-18.04           Running         2\n Ubuntu-18.04更换国内源\n首先备份一下默认的源\n1cp /etc/apt/sources.list /etc/apt/sourses.list.bak\n更换默认源为阿里源, 使用 sudo vim /etc/apt/sources.list 命令编辑，删除原来的内容，添加下面的阿里源信息\n12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n更换源之后，使用下面的命令更新一下\n12sudo apt-get updatesudo apt-get upgade\n 安装配置 Windows Terminal\n 下载 Windows Terminal\nWindows Terminal 是win推出的最新的一款命令行工具，可以在应用商店里搜索并下载，安装完成打开界面如下\n\n关于其的介绍这里就不多展开，这里记录如何使用Windows Terminal 连接WSL 2并安装配置zsh。\n 安装zsh\n12345# 安装 zshsudo apt-get install zsh# 修改默认的 Shell 为 zshchsh -s /bin/zsh\n 安装 oh-my-zsh\noh-my-zsh用于快速配置zsh，进入官网或者Github可以了解其基本使用及其丰富的主题使用，安装只需要执行下面代码即可\n1sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n安装zsh-syntax-higlighting语法高亮插件\n123456789101112131415161718192021# 下载git clone https://github.com/zsh-users/zsh-syntax-highlighting.git# 移动到 plugins 文件夹中mv -p zsh-syntax-highlighting $ZSH_CUSTOM/plugins# 配置环境变量cd ~vim .zshrc#在 plugins 一列中添加 zsh-syntax-highlighting，如下plugins=(         git         zsh-syntax-highlighting         )# 在文件最后添加source $ZSH_CUSTOM/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh# 配置生效source ~/.zshrc\n安装zsh-autosuggestions语法历史记录插件\n12345678910111213141516171819202122# 下载git clone https://github.com/zsh-users/zsh-autosuggestions.git# 移动到 plugins 文件夹中mv -p zsh-autosuggestions $ZSH_CUSTOM/plugins# 配置环境变量cd ~vim .zshrc#在 plugins 一列中添加 zsh-autosuggestions，如下plugins=(         git         zsh-syntax-highlighting         zsh-autosuggestions         )# 在文件最后添加source $ZSH_CUSTOM/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh# 配置生效source ~/.zshrc\n配置完成之后，默认的主题光标如下所示，如果想要配置更加丰富的主题，可以自行百度\n\n 安装并配置Docker环境\n 在WSL 2中安装 Docker\n卸载旧版本\n1sudo apt-get remove docker docker-engine docker.io containerd runc\n设置存储库\n12345678910111213141516# 更新 apt 包索引sudo apt-get update# 安装软件包以允许 apt 通过 HTTPS 使用存储库sudo apt-get install \\    apt-transport-https \\    ca-certificates \\    curl \\    gnupg-agent \\    software-properties-common# 设置稳定的存储库sudo add-apt-repository \\   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\   $(lsb_release -cs) \\   stable\"\n安装Docker 社区版(docker-ce)\n1234567# 更新 apt 包索引sudo apt-get update# 安装最新版本的 Docker 和 containerdsudo apt-get install docker-ce docker-ce-cli containerd.io# (*)安装特定版本;&lt;VERSION&gt; 为具体版本,例如 18.09.1sudo apt-get install docker-ce=&lt;VERSION&gt; docker-ce-cli=&lt;VERSION&gt; containerd.io\n启动 docker 并设置开机自启\n1234# 启动 dockersystemctl start docker.service# 设置开机自启systemctl enable docker.service\n如果非 root 用户想要使用 docker ，需要将该用户添加到 docker 用户组\n1sudo usermod -aG docker user-name\n(*)卸载docker\n1234# 卸载软件sudo apt-get purge docker-ce# 删除 docker 的容器,镜像,卷等存储sudo rm -rf /var/lib/docker\n 下载安装 Docker Desktop WSL 2 backend\nWSL 2 引入了重大的体系结构更改，因为它是 Microsoft 构建的完整 Linux 内核，允许 Linux 容器在没有仿真的情况下本机运行，而 Docker 也专门开发了可以使用 WSL 2 中的 Docker 守护进程的桌面管理程序, 打开 Docker Desktop WSL2 backend 页面，下载最新的程序,安装之后,打开程序做如下设置\n\n\n启用基于实验性WSL 2的引擎复选框(Enable the experimental WSL 2 based engine)\n\n\n\n(*) 暴露 2375 端口，让外部其他程序也能管理 Docker (打开 Expose daemon on tcp://localhost:2375 without TLS 前面的复选框)\n\n\n在 Resources 中设置要从哪个 WSL 2 发行版中访问 Docker，如下图使用的是 Ubuntu-18.04\n\n\n\n配置完成之后,点击 Apply &amp; Restart 应用并重启 Docker Desktop 。重启完成之后，我们看到 Desktop 左下脚的 Docker 状态为绿色的 running 表示 Docker 正在运行。\n要想知道自己安装的 Docker 的相关版本信息，我们可以在 About Docker Desktop 中看到，如下图所示，目前安装的 Docker Engine 版本为 19.03.5 ，Docker-compose 版本为 1.25.1-rc1 ，支持的 Kubernetes 版本为 v1.15.5  。\n\n 安装并配置 Kubernetes 环境\n 修改 Docker daemon 配置\ndocker 默认 Cgroup Driver 为 cgroup ，但是在 kubernetes1.14 之后的版本推荐使用 systemd 来作为 Docker 的 cgroup 驱动 。使使用 vim /etc/docker/deamon.json 命令修改或新建配置，具体配置内容可以参考 Kubernetes 官方。\n另外我们还需要配置一下 Docker 国内的镜像源，加速你的镜像下载速度，一般使用的有阿里和中科大的镜像源。上面的两项配置步骤如下\n12345678910111213141516# 编辑 deamon 文件vim /etc/docker/deamon.json# 输入如下内容&#123;  \"registry-mirrors\": [\"https://6e0d9uoa.mirror.aliyuncs.com\",\"https://docker.mirrors.ustc.edu.cn\"],  \"exec-opts\": [\"native.cgroupdriver=systemd\"],  \"log-driver\": \"json-file\",  \"log-opts\": &#123;    \"max-size\": \"100m\"  &#125;,  \"storage-driver\": \"overlay2\"&#125;# 重启 Dockersudo service docker restart\n 下载 Kubernetes 所需的镜像\n由于国内网络的问题，如果你不开代理，直接在 Decker Desktop 中选择启用 Kubernetes 是启动不了的，还好阿里云容器服务在 Github 上有开源 Docker Desktop for Mac/Windows  开启  Kubernetes 的项目，我们只需要下载下来，执行脚本就能把所有 Kubernetes 所需要的镜像都下载到本地。\n1234567#将项目下载到本地git clone https://github.com/AliyunContainerService/k8s-for-docker-desktop#进入项目目录cd k8s-for-docker-desktop#由于最新 master 已经支持 kubernetes v1.15.5,所以直接执行下载脚本即可./load_images.sh\n待所有镜像下载完成之后，我们在使用 docker images 可以看到下载的容器\n123456789101112REPOSITORY                                                       TAG                 IMAGE ID            CREATED             SIZEk8s.gcr.io/kube-apiserver                                        v1.15.5             e534b1952a0d        2 months ago        207MBk8s.gcr.io/kube-proxy                                            v1.15.5             cbd7f21fec99        2 months ago        82.4MBk8s.gcr.io/kube-controller-manager                               v1.15.5             1399a72fa1a9        2 months ago        159MBk8s.gcr.io/kube-scheduler                                        v1.15.5             fab2dded59dd        2 months ago        81.1MBquay.io/kubernetes-ingress-controller/nginx-ingress-controller   0.26.1              29024c9c6e70        2 months ago        483MBdocker/kube-compose-controller                                   v0.4.23             a8c3d87a58e7        6 months ago        35.3MBdocker/kube-compose-api-server                                   v0.4.23             f3591b2cb223        6 months ago        49.9MBk8s.gcr.io/coredns                                               1.3.1               eb516548c180        11 months ago       40.3MBk8s.gcr.io/kubernetes-dashboard-amd64                            v1.10.1             f9aed6605b81        12 months ago       122MBk8s.gcr.io/etcd                                                  3.3.10              2c4adeb21b4f        12 months ago       258MBk8s.gcr.io/pause                                                 3.1                 da86e6ba6ca1        24 months ago       742kB\n 启用 Kubernetes\n我们在 Docker Desktop 的设置中选择启用 kubernetes ，然后点击 Apply &amp; Restart 重启。\n\n如果运气好的话，当你重启之后你就会发现 Desktop 左下脚 Docker 和 Kubernetes 的状态都变成了绿色的 runnning ，但是很有可能你重启之后， kubernetes 的状态一直是黄色的 starting 。出现这种情况不要着急，我们可以在 C:\\ProgramData\\DockerDesktop下的 service.txt 查看启动的日志信息，一般情况下，启动不成功，出现最多的日志信息为下面的重复内容\n12[08:57:24.359][ApiProxy          ][Info   ] time=\"2019-12-20T08:57:24+08:00\" msg=\"cannot list nodes: Get https://kubernetes.docker.internal:6443/api/v1/nodes: EOF\"[08:57:24.359][GoBackendProcess  ][Info   ] time=\"2019-12-20T08:57:24+08:00\" msg=\"external: POST /events 200 \\\"Go-http-client/1.1\\\" \\\"\\\"\"\n出现这种情况，可以参考 Issue 3769(comment)和  Issue 1962(comment)，其实总结下来就是下面的几个操作：\n\n\n修改 host 文件，将 127.0.0.1 kubernetes.docker.internal 映射信息添加到 host 文件中\n\n\n修改网络连接的 DNS 地址为 8.8.8.8 ， win 下如何修改网络连接的 DNS 可以自行百度\n\n\n删除 C:\\ProgramData\\DockerDesktop 目录下的 pki 目录文件\n\n\n删除 C:\\Users\\&lt;yourname&gt;目录下 的.kube 目录文件\n\n\n关闭 win 的网络防火墙，或者将 vpnkit.exe 添加到防火墙出入站规则中。\n\n\n在 Desktop 中点击进入 troubleshoot ，点击重置 kubernetes 集群(Reset Kubernetes cluster)\n\n\n\n如果上述操作一次下来还是不成功，建议重复操作几次。如果出现了其他的问题，一般到 docker\\for-win 项目的 issue下可以找到解决方法。如果启动成功了，我们在命令行下执行下面的命令可以验证\n12345678$ kubectl cluster-infoKubernetes master is running at https://kubernetes.docker.internal:6443KubeDNS is running at https://kubernetes.docker.internal:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxyTo further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.$ kubectl get nodesNAME             STATUS   ROLES    AGE   VERSIONdocker-desktop   Ready    master   6h    v1.15.5\n 部署 Kubernetes dashboard\nKubernetes dashboard是 Kubernetes集群的基于 Web的通用 UI。它允许用户管理集群中运行的应用程序并对其进行故障排除，以及管理集群本身。执行下面命命令即可部署\n12345678# 新建 dashboard 资源kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml# (*)如果上面命令执行说网络连接有问题，把 yaml 文件下载到本地，然后执行kubectl apply -f kubernetes-dashboard.yaml# 开启 API Server 访问代理kubectl proxy\n部署完成之后，我们通过如下 URL 即可访问 Kubernetes dashboard\n\nhttp://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/login\n\n进入 Dashboard 需要令牌，可以通过以下命令获取令牌，将生成的令牌复制粘贴到令牌登录输入框即可。\n1kubectl -n kube-system describe secret default| awk '$1==\"token:\"{print $2&#125;'\n 下载安装 Helm\nHelm是 Deis 开发的一个用于 kubernetes 的包管理器。每个包称为一个 Chart ， Helm 客户端安装十分简单，我们可以到 Github下载最新的可执行程序，解压出来就可以使用了，具体操作步骤可如下：\n1234567# 下载 v2.16.1 版本wget https://get.helm.sh/helm-v2.16.1-linux-amd64.tar.gz# 解压tar -zxvf helm-v2.16.1-linux-amd64.tar.gzcd linux-amd64/# 移动到 /usr/local/bin 目录下cp helm /usr/local/bin/\n服务端 tiller 安装起来就相对来说不是那么容易了，因为要下载墙外的镜像。好在 Docker Hub  上有别人打包上传的镜像，我们只需要 pull 下来，打个 tag 即可，具体步骤如下：\n1234# 下载镜像到本地docker pull doublemine/kubernetes-helm.tiller:v2.16.1# 添加 tagdocker tag doublemine/kubernetes-helm.tiller:v2.16.1 gcr.io/kubernetes-helm/tiller:v2.16.1\n服务端的镜像下载到本地之后，我们就可以在集群上安装 tiller ，我们可以运行下面的命令来创建服务账号和初始化客户端\n123kubectl create serviceaccount tiller -n kube-systemkubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount kube-system:tillerhelm init --wait --service-account tiller\n安装和初始化完成之后，我们想要验证 tiller 服务是否运行，可以使用如下命令\n1234567891011$ kubectl get pod --namespace kube-systemNAME                                     READY   STATUS    RESTARTS   AGEcoredns-5c98db65d4-7rn5b                 1/1     Running   0          12hcoredns-5c98db65d4-bx9x2                 1/1     Running   0          12hetcd-docker-desktop                      1/1     Running   0          12hkube-apiserver-docker-desktop            1/1     Running   0          12hkube-controller-manager-docker-desktop   1/1     Running   0          12hkube-proxy-rdtfm                         1/1     Running   0          12hkube-scheduler-docker-desktop            1/1     Running   0          12hkubernetes-dashboard-7d75c474bb-qcbxx    1/1     Running   0          4h46mtiller-deploy-54f7455d59-fgsnb           1/1     Running   0          12h\n我们可以看到最后一列显示 tiller 服务正在运行。\n Helm 配置国内镜像源\n当我们使用 helm 安装应用的时候，我们会发现下载速度特别慢，还有可能会遇到网络的问题，这种情况我们需要配置其默认下载的镜像源为国内。具体配置步骤如下：\n12345678910# 删除默认的镜像源helm repo remove stable# 增加新的国内镜像源helm repo add stable http://mirror.azure.cn/kubernetes/charts/helm repo add incubator http://mirror.azure.cn/kubernetes/charts-incubator/# 更新仓库sudo helm repo update# 测试速度helm search mysql\n","thumbnail":"https://images.unsplash.com/photo-1484417894907-623942c8ee29?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjk3ODd9&auto=format&fit=crop&w=2689&q=80","plink":"https://dmego.me/2019/12/21/make-wsl2-as-a-productivity-tool/"},{"title":"许嵩博文句子摘录","date":"2018-12-08T15:32:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.529Z","content":"\n\n\n\n摘录了一些许嵩博文里的一些句子，可供日后品味。无关好坏，只是单纯自己喜欢罢了。\n\n有人让我感动，有人让我恶心。这就叫生活。\t——原文链接\n\n\n写悲伤的歌不代表眼下刚好失恋。写明亮的歌不代表当前刚好愉悦。\t——《安徒生不后悔》\n\n\n写下几行诗句\n最押韵的\n竟然是我的叹息\t——《静夜思》\n\n\n心无城府的人，怎样穿越现世的深宅大院。\t——原文链接\n\n\n《珍惜》  ——原文链接\n明明没有睡着，却在半夜撑着对你说已经一觉睡醒的人，是爱你的。\n人总是在失去后学会珍惜。我是人，我失去过，所以我学会了。\n可由于我们每个人都力量微小。珍惜，未必能让菩萨动容，世界感应，灵魂颤抖。\n更多的可能，不过换来抿嘴一笑，不屑一顾，拂袖一去。\n\n\n不抱太多希望，总归就没什么可失望；没什么失意的，就凑合着假装快乐吧。\t——《夜行》\n\n\n做一个爽的人。不弯弯绕。虽然这也许会让别人不爽。\n真相和实话往往不那么美好。但还是应该倡导清醒决绝。宁可接受不甚美好的真相，不能浸淫假面和泡沫。喜爱幻觉带来的短期麻痹，后遗症终归还是会在某一刻积累爆发。\n瞧那些可怜的。\n最近感觉特别好，兴许氟利昂的味道又在起作用。闻着，是很容易写出一些歌。供自己在以后的时间里，听着它们，温习领悟当下看似无甚抑扬顿挫的时光。\t——原文链接\n\n\n从来不会输，如果不计成败。\t——《有何不可》\n\n\n如果把活着的每一天当成生命的最后一天谨慎对待，或许时间会被用的更有价值。可是如果每个人都确切的知道自己的死期，想一下，这个世界将多么疯狂，有人抓紧时间行善，有人抓紧时间作恶。\n生命之所以伟大，本就在于那一滴星光散去过后的下一个天明，是未知的。    ——《三月星光》\n\n\n人出生的这一日，岂非正是死亡倒计时的开始？非但我要死，人人都是一生下来就要奔着死亡而去的。\t——《二十三》\n\n\n太过热烈的氛围里氧气总是会稀薄，让人脑袋缺氧思维僵化。\t——原文链接\n\n\n人生之所以有趣是因为充满未知。那些觉得人生无趣的人，只不过是自以为已知了自己的将来、看不到希望。事实上，希望总藏匿在转角处，不走到跟前，万万是看不见的。\t——原文链接\n\n\n它们并没有利益上的直接冲突，一个吃生米，一个吃肉。或许只因为它们是异类，所以终究无法共存。很多时候我们被人害，也未必需要从利害角度去分析敌人的动机。看不过眼，就是一种天然的动机。\n旁人眼里的亲密无间代表不了什么。\t\t——《异类》\n\n\n世间事太过复杂，你以为无意间得到了真相，并为此自喜，其实错误的荆棘才刚刚在你心里播种。\t——《带灰的饭》\n\n\n《雨夜》  ——原文链接\n当深夜车辆足够稀疏的时候，宽阔的道路方能显示出一些属于它自己的真相——那些在白天各式各样的倾轧之下不为人所见的。\n夜雨把一个人彻底淋湿。但并不以一种清洁的姿态。\n\n\n人生的进阶并非是随着年龄增长就可自动完成的。四肢动脑子不动，或脑子动四肢不动，都注定只能在原地。\t——《越位》\n\n\n一个人对我说：许多念念不忘，只是一瞬；许多一瞬，却是念念不忘。\n悲剧的是，我们所历经的，更多是前者。\t\t——《一瞬》\n\n\n关于爱情，我他妈明明努力过。\t——《三两句》\n\n\n如果，岁月在你脸上已然留下不少年轮——你坐船的动机仍然只是到达一座岛，别人把岛上的一切美妙和宝藏说给你听就可以让你划船划的更带劲儿——那我能对你说些什么呢？\n也许你一直怀揣理想，那也不是什么了不得的坏事，没什么了不得的，只管去实现好了。只不过你应知道，坐船的意义就仅仅是坐船，如果坐船是为了到达目的地，那所有人最终的目的地都是死亡。\t——《出离》\n\n\n如果你的真实让你心清目明，自得其乐，那你也不会再有心思去指责别人。\n往远点说。人们的分别心一直都是这么重。“这是好的”、“那是坏的”，却不知自己最看不惯的可能是别人最欣赏的，自己最欣赏的可能是别人最不屑的。\t——《分别心》\n\n还有两篇我觉得充满哲理的文章\n\n——《无常》\n——《分别心》\n\n\n2018 年 12 月 8 日 晚\n\n","plink":"https://dmego.me/2018/12/08/excerpts-from-xusong-blog/"},{"title":"决策模型(二)：风险决策法","date":"2018-11-12T00:00:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.545Z","content":"\n\n## 前言\n风险决策法是指决策者对客观情况不了解，但是对将发生各事件的概率是已知的。决策者往往通过调查，根据过去的经验或主观估计等途径获得这些概率。在风险决策中一般采用期望值作为决策准则，常用的有最大期望收益决策准则（EMV）和最小机会损失决策准则（EOL）。\n风险型决策问题一般具有以下特点:\n\n决策具有明确目标: 获得最大收益（利润）或最小损失；\n存在两个以上可供选择的行动方案\n存在两个或两个以上不以决策者主观意志为转移的自然状态，但决策者根据过去的经验，主观估计或科学理论等可预先估算出这些状态出现的概率值；\n各行动方案在确定状态下的损益值可以计算出来；\n\n下面接着上一篇博文，对文中的例子做风险决策分析，决策矩阵如下：\n\n\n\n（策略\\事件）\nE1 = 0\nE2 = 10\nE3 = 20\nE4 = 30\nE5 = 40\n\n\n\n\n事件概率（pj）\n0.1\n0.2\n0.4\n0.2\n0.1\n\n\nS1 = 0\n0\n0\n0\n0\n0\n\n\nS2 = 10\n-10\n50\n50\n50\n50\n\n\nS3 = 20\n-20\n40\n100\n100\n100\n\n\nS4 = 30\n-30\n30\n90\n150\n150\n\n\nS5 = 40\n-40\n20\n80\n140\n200\n\n\n\n(注：记各自然状态发生的概率为\np_j\n\n\n\n\n\n \n \n\n，采用第 i 种方案在发生第 j 自然状态下的损益值为 \na_{ij}\n\n\n\n\n\n\n \n\n \n \n\n\n)\n 最大期望收益决策准则（EMV）\n 定义\n最大期望收益决策，显而易见，就是计算出每个方案期望收益值，然后选取最大期望值对应的方案即为最优方案。\n 计算步骤\n先根据各事件发生的概率 \np_j\n\n\n\n\n\n \n \n\n，求出各个策略的期望收益值。然后从这些期望收益值中选择最大者，它对应的策略为决策应选策略。\n 计算公式\n\nS*k \n\\rightarrow\n\n\n\n\n \n\n max \n\\sum_{j} p_ja_{ij}\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n \n\n \n \n\n\n\n\n\n 计算结果\n\n\n\n（策略\\事件）\nE1 = 0\nE2 = 10\nE3 = 20\nE4 = 30\nE5 = 40\nEMV\n\n\n\n\n事件概率（pj）\n0.1\n0.2\n0.4\n0.2\n0.1\n\n\n\nS1 = 0\n0\n0\n0\n0\n0\n0\n\n\nS2 = 10\n-10\n50\n50\n50\n50\n44\n\n\nS3 = 20\n-20\n40\n100\n100\n100\n76\n\n\nS4 = 30\n-30\n30\n90\n150\n150\n84 \n\\longleftarrow\n\n\n\n\n \n\n max\n\n\nS5 = 40\n-40\n20\n80\n140\n200\n80\n\n\n\n根据 EMV 决策准则有\n\nmax (0 , 44 , 76, 84, 80) = 84\n\n对应的决策策略为 S4，为决策者选择的策略。\nEMV 决策准则适用于一次决策多次重复进行生产的情况，所以它是平均意义下的最大收益。\n 计算代码\n123456789101112131415161718192021222324252627282930313233343536373839404142private static int row = 4; //行private static int col = 3; //列private static double t =2; //效用曲率系数private static double[][] matrix = &#123;//决策矩阵     //事件     1   2   3            &#123;0.2,0.5,0.3&#125;,  //事件概率            &#123;140,120, 80&#125;,  //策略            &#123;200,150, 40&#125;,  //策略            &#123;340,140,-20&#125;,  //策略    &#125;;/** * 最大期望收益决策准则(EMV) * @param matrix * @param row * @param col */private static void EMV(double[][] matrix, int row, int col)&#123;    double[] maxMar = new double[row+1]; //记录每种行动方案的结果，第一行是自然状态概率    double max = 0.0; //最优结果    double temp = 0.0;    double chance = 0.0; //概率    int maxIndex = 0; //最优结果下标    //因为第一行是自然状态概率，所以从第二行开始，实际的行数比 row 多一行    for (int i = 1; i &lt;= row; i++) &#123;        for (int j = 0; j &lt; col; j++) &#123;            chance =  matrix[0][j]; //自然概率            temp = (j != 0) ? (temp + matrix[i][j]*chance) : (matrix[i][j]*chance);        &#125;        maxMar[i] = temp;        if(i == 1)&#123; // 当 i=1时，为 max 与 maxIndex 赋初值            max = temp;            maxIndex = 1;        &#125;else if(temp &gt; max)&#123;            max = temp;            maxIndex = i;        &#125;    &#125;    System.out.println(Arrays.toString(maxMar));    System.out.println(max+\"--\"+maxIndex);&#125;\n 最小机会损失决策准则（EOL）\n 定义\n最小机会损失决策与不确定型决策法里的最小机会损失决策准则相类似，都是先将收益矩阵的中各元素变换为机会损失值。将各自然状态下的最大收益值定为理想目标，并将该状态中的其他值与最高值之差称为机会损失值。然后求这些机会损失值的期望损失值，最后从中选取最小的期望损失值，对应的策略即为决策者所选的策略。\n 计算步骤\n首先计算出当发生 j 事件后，各策略的收益最大值\n\naij = max ( aij )\n\n这时各策略的机会损失值为\n\n\na'_{ij}\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n = { max ( aij ) - aij }\n\n然后求这些机会损失值的期望损失值，最后从中选取最小的期望损失值\n\nmin \n\\sum_{j} p_ja'_{ij}\n\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n \n \n\n \n \n\n\n\n\n\n 计算公式\n\nS*k  \n\\rightarrow\n\n\n\n\n \n\n min \n\\sum_{j} p_ja'_{ij}\n\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n \n \n\n \n \n\n\n\n\n\n 计算结果\n\n\n\n（策略\\事件）\nE1 = 0\nE2 = 10\nE3 = 20\nE4 = 30\nE5 = 40\nEOL\n\n\n\n\n事件概率（pj）\n0.1\n0.2\n0.4\n0.2\n0.1\n\n\n\nS1 = 0\n0\n50\n100\n150\n200\n100\n\n\nS2 = 10\n10\n0\n50\n100\n150\n56\n\n\nS3 = 20\n20\n10\n0\n50\n100\n24\n\n\nS4 = 30\n30\n20\n10\n0\n50\n16 \n\\longleftarrow\n\n\n\n\n \n\n max\n\n\nS5 = 40\n40\n30\n20\n10\n0\n20\n\n\n\n根据 EOL 决策准则有\n\nmin (100, 56 , 24, 16, 20) = 16\n\n对应的决策策略为 S4，为决策者选择的策略。\n从本质上讲 EMV 与 EOL 决策准则是一样的。所以决策时这两个决策结果是一样的。\n 计算代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 最小机会损失决策准则(EOL) * @param matrix * @param row * @param col */private static void EOL(double[][] matrix, int row, int col)&#123;    //先求损失矩阵    double[][] loss = new double[row+1][col];    for (int j = 0; j &lt; col; j++) &#123;        loss[0][j] = matrix[0][j]; //将自然概率复制到损失矩阵的第一行中        double max = matrix[1][j]; //先定每一列的第一个最大        for (int i = 1; i &lt;= row; i++) &#123;            if(matrix[i][j] &gt; max)&#123;                max = matrix[i][j];            &#125;        &#125;        //此时已经求出该列的最大值        //损失矩阵中对应位置的值 = 决策矩阵中列最大值 - 决策矩阵中对应位置值        for (int i = 1; i &lt;= row; i++) &#123;            loss[i][j] = max - matrix[i][j];        &#125;    &#125;    //然后再求 EOL 决策    double[] maxMar = new double[row+1];    double min = 0.0;    double temp = 0.0;    int minIndex = 0;    double chance = 0.0;    for (int i = 1; i &lt;= row; i++) &#123;        for (int j = 0; j &lt; col; j++) &#123;            chance =  loss[0][j]; //自然概率            temp = (j != 0) ? (temp + loss[i][j]*chance) : (loss[i][j]*chance);        &#125;        maxMar[i] = temp;        if(i == 1)&#123;            min = temp;            minIndex = 1;        &#125; else if(temp &lt; min)&#123;            min = temp;            minIndex = i;        &#125;    &#125;        System.out.println(Arrays.toString(maxMar));    System.out.println(min+\"--\"+minIndex);&#125;\n 全情报的价值（EVPI）\n 定义\n当决策者耗费了一定经费进行调研，获得了各事件发生概率的信息，应采用 ”随机应变“ 的战术，这时所得的期望收益称为全情报的期望收益，记做 EPPI，这个收益应当大于至少等于最大期望收益，即 EPPI &gt;= max（EMV），则有EVPI = EPPL - max(EMV)，EVPI 称为全情报的价值，这就说明获得情报的费用不能超过 EVPI 值，否则就没有增加收入。\n 计算步骤\n先进行 EMV 决策法计算，求得最大期望收益值\n\nmax \n\\sum_{j} p_ja_{ij}\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n \n\n \n \n\n\n\n\n\n然后求全情报期望收益，先得求收益矩阵中每行的最大值然后求期望，最后将每行最大值的期望相加，得到全情报期望收益。\n\n\n\\sum_{j} p_jmax(a_{i})\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n \n \n \n \n\n \n \n\n \n\n ; \nmax(a_{i})\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n\n \n\n 是 i 行的最大值\n\n全情报期望收益减去最大期望收益即为全情报价值 EVPI\n\nEVPI = \n\\sum_{j} p_jmax(a_{i})\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n \n \n \n \n\n \n \n\n \n\n - max \n\\sum_{j} p_ja_{ij}\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n \n\n \n \n\n\n\n\n\n 计算公式\n\nEVPI = \n\\sum_{j} p_jmax(a_{i})\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n \n \n \n \n\n \n \n\n \n\n - max \n\\sum_{j} p_ja_{ij}\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n \n\n \n \n\n\n\n\n\n 计算结果\n\n\n\n（策略\\事件）\nE1 = 0\nE2 = 10\nE3 = 20\nE4 = 30\nE5 = 40\nEMV\n期望收益\nEVPI\n\n\n\n\n事件概率（pj）\n0.1\n0.2\n0.4\n0.2\n0.1\n\n\n\n\n\nS1 = 0\n0\n0\n0\n0\n0\n0\n\n\n\n\nS2 = 10\n-10\n50\n50\n50\n50\n44\n\n\n\n\nS3 = 20\n-20\n40\n100\n100\n100\n76\n\n\n\n\nS4 = 30\n-30\n30\n90\n150\n150\n84 \n\\longleftarrow\n\n\n\n\n \n\n max\n100\n16\n\n\nS5 = 40\n-40\n20\n80\n140\n200\n80\n\n\n\n\n\n根据 EMV 决策准则有\n\nmax (0, 44, 76 , 84, 80) = 84\n\n得到最大的期望收益值为 84 , 再求得全情报期望收益 = 100 ,最后可得全情报价值EVPI = 16, 对应的决策策略为 S4，为决策者选择的策略。\n 计算代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 /**  * 全情报价值(EVPI)  * @param matrix  * @param row  * @param col  */private static void EVPI(double[][] matrix, int row, int col)&#123;    double[] maxMar = new double[row+1]; //记录每种行动方案的结果，第一行是自然状态概率    double max = 0.0; //最优结果    double temp = 0.0;    double chance = 0.0; //概率    int maxIndex = 0; //最优结果下标    //因为第一行是自然状态概率，所以从第二行开始，实际的行数比 row 多一行    for (int i = 1; i &lt;= row; i++) &#123;        for (int j = 0; j &lt; col; j++) &#123;            chance =  matrix[0][j]; //自然概率            temp = (j != 0) ? (temp + matrix[i][j]*chance) : (matrix[i][j]*chance);        &#125;        maxMar[i] = temp;        if(i == 1)&#123; // 当 i=1时，为 max 与 maxIndex 赋初值            max = temp;            maxIndex = 1;        &#125;else if(temp &gt; max)&#123;            max = temp;            maxIndex = i;        &#125;    &#125;    double rowMax = 0.0;    double expect = 0.0;    double chance = 0.0;    double value = 0.0;    //计算全情报价值收益    for (int i = 0; i &lt; col; i++) &#123;        chance =  matrix[0][i]; //自然概率        for (int j = 1; j &lt;= row; j++) &#123;            if(j == 1)&#123; //初始化第一行第一个为该行最大的收益值                rowMax = matrix[j][i];            &#125;else if (matrix[j][i] &gt; rowMax)&#123;                rowMax = matrix[j][i];            &#125;        &#125;        expect += rowMax * chance;    &#125;        except = new BigDecimal(expect).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();    value = new BigDecimal(expect - max).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();        System.out.println(\"全情报期望收益:\"+except);    System.out.println(\"全情报价值EVPI:\"+value);&#125;\n 效用曲线拟合（EUV）\n 定义\n效用概念首先是由贝努里提出的,他认为人们对其钱财的真实价值的考虑与他的钱财拥有量有对数关系。经济管理学家将效用作为指标，用它来衡量人们对某些事物的主观价值，态度，偏爱，倾向等。例如在风险情况下进行决策，决策者对风险的态度是不同的，用效用指标来量化决策者对待风险的态度，可以给每一个决策者测定他对待风险的态度的效用曲线函数。这里还有一个概率是效用曲线系数，效用曲线系数的取值范围为（0,∞）。\n\n 计算步骤\n先建立效用曲线函数，将矩阵中的收益值装化为效用值，其中 t 为效用曲线系数，b=max{x1,x2,x3,⋯,xn} ，a=min{x1,x2,x3,⋯,xn}) ；\n\nU(x) = \n\\left\\{\\begin{matrix} &amp;0, &amp; x\\leq a  &amp; \\\\ &amp;(\\frac{x-a}{b-a})^t, &amp; a\\leq x\\leq b  \\\\ &amp;1, &amp;x\\geq b \\end{matrix}\\right.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n\n \n\n \n\n\n\n\n \n \n\n\n \n\n\n\n\n \n \n \n\n\n \n \n \n\n\n\n\n \n \n\n \n\n\n \n \n\n\n\n\n \n \n \n\n\n \n \n \n \n \n\n\n \n \n \n\n\n\n\n\n\n然后计算期望效用值,结果为期望效用的最大值\n\nEUVi = \n\\sum_{j} p_ju_{ij}\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n \n\n \n \n\n\n\n\n\n 计算公式\n\nS*k  \n\\rightarrow\n\n\n\n\n \n\n max \n\\sum_{j} p_ju_{ij}\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n \n\n \n \n\n\n\n\n\n 计算结果\n\n\n\n（策略\\事件）\nE1 = 0\nE2 = 10\nE3 = 20\nE4 = 30\nE5 = 40\nEUV（t=2）\n\n\n\n\n事件概率（pj）\n0.1\n0.2\n0.4\n0.2\n0.1\n\n\n\nS1 = 0\n0.03\n0.03\n0.03\n0.03\n0.03\n0.03\n\n\nS2 = 10\n0.02\n0.14\n0.14\n0.14\n0.14\n0.128\n\n\nS3 = 20\n0.01\n0.11\n0.34\n0.34\n0.34\n0.261\n\n\nS4 = 30\n0.0\n0.09\n0.29\n0.63\n0.63\n0.323\n\n\nS5 = 40\n0.0\n0.06\n0.25\n0.56\n1.0\n0.324 \n\\longleftarrow\n\n\n\n\n \n\n max\n\n\n\n根据 EUV决策准则有\n\nmax (0.03, 0.128 , 0.261, 0.323, 0.324) = 0.324\n\n对应的决策策略为 S5，为决策者选择的策略。\n 计算代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 效用曲线拟合(EUV) * @param matrix * @param row * @param col */private static void EUV(double[][] matrix, double a, int row, int col)&#123;    //先求出收益矩阵中的最大值与最小值    double min = matrix[1][0];    double max = matrix[1][0];    for (int i = 2; i &lt; row; i++) &#123;        for (int j = 0; j &lt; col; j++) &#123;            if(matrix[i][j] &gt; max)&#123;                max = matrix[i][j];            &#125;            if(matrix[i][j] &lt; min)&#123;                min = matrix[i][j];            &#125;        &#125;    &#125;    System.out.println(\"min=\"+min+\"max=\"+max);    //然后求出效用值矩阵    /*计算方法           小于最小值(a) =&gt; 0           大于最大值(b) =&gt; 1           介于之间=&gt; (x-a/b-a)^t,其中t为效用曲线系数         */    double[][] avail = new double[row+1][col];        for (int i = 1; i &lt;= row; i++) &#123;            for (int j = 0; j &lt; col; j++) &#123;                avail[0][j] = matrix[0][j]; //将自然状态概率复制到第一行中                if(matrix[i][j] &lt;= min)&#123;                    avail[i][j] = 0.0;                &#125;else if(matrix[i][j] &gt;= max)&#123;                    avail[i][j] = 1.0;                &#125;else &#123;                    double pow = Math.pow((matrix[i][j] - min) / (max - min), t);                    avail[i][j] = new BigDecimal(pow).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();                &#125;            &#125;        &#125;    for (int i = 0; i &lt; row; i++) &#123;        System.out.println(Arrays.toString(avail[i]));    &#125;    //再求期望效用值     double[] maxMar = new double[row+1];        double availMax = 0.0; //效用期望最大值        int maxIndex = 0;        double temp = 0.0;        double chance = 0.0;        for (int i = 1; i &lt;= row; i++) &#123;            for (int j = 0; j &lt; col; j++) &#123;                chance =  avail[0][j]; //自然概率                temp = (j != 0) ? (temp + avail[i][j]*chance) : (avail[i][j]*chance);            &#125;            double value =new BigDecimal(temp).setScale(3, BigDecimal.ROUND_HALF_UP).doubleValue();            maxMar[i] = value;            if(i == 1)&#123;                availMax = value;                maxIndex = 1;            &#125; else if(value &gt; availMax)&#123;                availMax = value;                maxIndex = i;            &#125;        &#125;    System.out.println(Arrays.toString(maxMar));    System.out.println(availMax+\"--\"+maxIndex);&#125;\n 总结\n至此，决策模型模块的所有算法模型都分析，建立并实现完成。\n 参考\n\n运筹学（第4版）本科版\n\n","plink":"https://dmego.me/2018/11/12/risk-decision-method/"},{"title":"决策模型(一)：不确定型决策法","date":"2018-11-04T20:26:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.505Z","content":"\n\n 前言\n所谓的不确定型的决策是指决策者对环境情况一无所知。这时决策者是根据自己的主观倾向进行决策，由决策者的主观态度的不同基本可分为四种准则：悲观主义决策准则、乐观主义决策准则、等可能性准则、最小机会损失决策准则。下面将以一个例子来说明这几种决策准则。\n\n设某工厂是按批生产某产品并按批销售，每件产品的成本为30元，批发价为每件35元，若每月生产的产品当月销售不完，则每件损失1元。工厂每投产一批是10件，最大月生产能力是40件，决策者可选者的方案可以是 0 件、10 件、20 件、30 件、40 件。假设决者对其产品的需求情况一无所知。问该决策者该如何决策？\n\n要想解决上诉问题，必须先知道决策矩阵。从问题中我们知道决策者可选的决策方案有五种，这是他们的策略集合，记做 {Si}，i = 1，2，···，5。经过我们分析，可断定将发生五种销售情况：销售 0 件、10 件、20 件、30 件、40 件，但是不知道他们发生的概率。这就是事件集合。记做{Ej&gt;}，j=1，2，···，5。而对于每个 ”策略—事件“ 对都可以计算出相应的收益值或损失值。例如单选择月产量为 20 件时，销售为 10 件。这时收益值为：\n\n10 x (35 - 30) - 1 x (20 - 10) = 40 元\n\n因此可以将每一个 ”策略—事件“ 对对应的收益值或损失值求出，记做 aij，将这些数据汇总在一个矩阵中，如下所示：\n\n\n\n（策略\\事件）\nE1 = 0\nE2 = 10\nE3 = 20\nE4 = 30\nE5 = 40\n\n\n\n\nS1 = 0\n0\n0\n0\n0\n0\n\n\nS2 = 10\n-10\n50\n50\n50\n50\n\n\nS3 = 20\n-20\n40\n100\n100\n100\n\n\nS4 = 30\n-30\n30\n90\n150\n150\n\n\nS5 = 40\n-40\n20\n80\n140\n200\n\n\n\n这就是决策矩阵，根据决策矩阵中元素所示的含义不同，可称为收益矩阵，损失矩阵，风险矩阵，后悔矩阵等。\n 悲观主义（max min）决策准则\n 定义\n悲观主义决策又被称为保守主义决策准则，他分析各种最坏的可能结果，然后从中选择最好的，以它对应的策略为决策策略，用符合表示为 max min 决策准则。\n 计算步骤\n在收益矩阵中先从各策略所对应的结果中选出最小值，将他们至于表的最右列，然后从此列中选出最大值，以他对应的策略为决策者应选的决策策略。\n 计算公式\n\nS*k \n\\rightarrow\n\n\n\n\n \n\n max min (aij )\n\n 计算结果\n\n\n\n（策略\\事件）\nE1 = 0\nE2 = 10\nE3 = 20\nE4 = 30\nE5 = 40\nmin\n\n\n\n\nS1 = 0\n0\n0\n0\n0\n0\n0 \n\\longleftarrow\n\n\n\n\n \n\n max\n\n\nS2 = 10\n-10\n50\n50\n50\n50\n- 10\n\n\nS3 = 20\n-20\n40\n100\n100\n100\n- 20\n\n\nS4 = 30\n-30\n30\n90\n150\n150\n- 30\n\n\nS5 = 40\n-40\n20\n80\n140\n200\n- 40\n\n\n\n根据 max min 决策准则有\n\nmax (0 , - 10 , - 20, - 30 , - 40) = 0\n\n对应的决策策略为 S1，为决策者选择的策略。在本例中为 “什么也不生产”，这个结论似乎很荒谬，但是在实际生产中表示先看一看，以后再做决定。\n 计算代码\n1234567891011121314151617181920212223242526/** * 悲观主义决策 * @matrix 决策矩阵 * @row 决策矩阵行数 * @col 决策矩阵列数 */public static void maxMin(double[][] matrix, int row, int col)&#123;    double[] maxMar = new double[row];    for (int i = 0; i &lt; row; i++) &#123;        double min = matrix[i][0]; //让第一个最小        for (int j = 1; j &lt; col; j++) &#123;            if(matrix[i][j] &lt; min)&#123;                min = matrix[i][j];            &#125;        &#125;        maxMar[i] = min;    &#125;    System.out.println(Arrays.toString(maxMar));    double max = maxMar[0];    for (int i = 0; i &lt; row; i++) &#123;        if(maxMar[i] &gt; max)&#123;            max = maxMar[i];        &#125;    &#125;    System.out.println(\"悲观主义决策结果：\"+max);&#125;\n 乐观主义（max max）决策准则\n 定义\n持有乐观主义决策准则的决策者对待风险的态度与悲观主义者不同，他不会放过任何一个获得最好结果的机会。来争取好中之好的乐观态度来选择他的决策策略。\n 计算步骤\n决策者在分析收益矩阵各”策略—事件“对的结果中选出最大者，记在表的最右列。再从该列数值中选出最大者，以它对应的策略为决策策略。\n 计算公式\n\nS*k  \n\\rightarrow\n\n\n\n\n \n\n max max (aij )\n\n 计算结果\n\n\n\n（策略\\事件）\nE1 = 0\nE2 = 10\nE3 = 20\nE4 = 30\nE5 = 40\nmin\n\n\n\n\nS1 = 0\n0\n0\n0\n0\n0\n0\n\n\nS2 = 10\n-10\n50\n50\n50\n50\n50\n\n\nS3 = 20\n-20\n40\n100\n100\n100\n100\n\n\nS4 = 30\n-30\n30\n90\n150\n150\n150\n\n\nS5 = 40\n-40\n20\n80\n140\n200\n200 \n\\longleftarrow\n\n\n\n\n \n\n max\n\n\n\n根据 max max 决策准则有\n\nmax (0 , 50 , 100, 150 , 200) = 200\n\n对应的决策策略为 S5，为决策者选择的策略。也就是选择每月生产 40 件。\n 计算代码\n1234567891011121314151617181920212223242526/** * 乐观主义决策 * @matrix 决策矩阵 * @row 决策矩阵行数 * @col 决策矩阵列数 */public static void maxMax(double[][] matrix, int row, int col)&#123;    double[] maxMar = new double[row];    for (int i = 0; i &lt; row; i++) &#123;        double max = matrix[i][0]; //让第一个最大        for (int j = 1; j &lt; 5; j++) &#123;            if(matrix[i][j] &gt; max)&#123;                max = matrix[i][j];            &#125;        &#125;        maxMar[i] = max;    &#125;    System.out.println(Arrays.toString(maxMar));    double max = maxMar[0];    for (int i = 0; i &lt; row; i++) &#123;        if(maxMar[i] &gt; max)&#123;            max = maxMar[i];        &#125;    &#125;    System.out.println(\"乐观主义决策结果：\"+max);&#125;\n 等可能性（Laplace）准则\n 定义\n等可能性（Laplace）准则是19世纪数学家 Laplace 提出的。该准则认为所以事件发生的概率是相等的。也就是每一事件发生的概率都是 1 / 事件数。\n 计算步骤\n决策者先计算各策略的收益期望值，然后在所有这些期望值中选择最大者。以它对应的策略为决策策略。\n 计算公式\n\nS*k  \n\\rightarrow\n\n\n\n\n \n\n max { E ( Si ) }\n\n 计算结果\n\n\n\n（策略\\事件）\nE1 = 0\nE2 = 10\nE3 = 20\nE4 = 30\nE5 = 40\nE (Si) = \n\\sum_{j} pa_{ij}\n\n\n\n\n\n\n\n\n \n \n \n\n \n\n \n \n\n\n\n\n\n\n\n\nS1 = 0\n0\n0\n0\n0\n0\n0\n\n\nS2 = 10\n-10\n50\n50\n50\n50\n38\n\n\nS3 = 20\n-20\n40\n100\n100\n100\n64\n\n\nS4 = 30\n-30\n30\n90\n150\n150\n78\n\n\nS5 = 40\n-40\n20\n80\n140\n200\n80 \n\\longleftarrow\n\n\n\n\n \n\n max\n\n\n\n在本例中 P = \n\\frac{1}{5}\n\n\n\n\n\n\n\n \n \n\n\n，期望值\n\nmax { E ( Si ) } = max {0, 38, 64, 78, 80 } = 80\n\n对应的策略 S5 为决策策略\n 计算代码\n123456789101112131415161718192021222324/** * 等概率准则决策 * @matrix 决策矩阵 * @row 决策矩阵行数 * @col 决策矩阵列数 */public static void laplace(double[][] matrix, int row, int col)&#123;    double[] maxMar = new double[row];    for (int i = 0; i &lt; row; i++) &#123;        double sum = 0;        for (int j = 0; j &lt; col; j++) &#123;            sum += matrix[i][j];        &#125;        maxMar[i] = sum / col;    &#125;    System.out.println(Arrays.toString(maxMar));    double max = maxMar[0];    for (int i = 0; i &lt; row; i++) &#123;        if(maxMar[i] &gt; max)&#123;            max = maxMar[i];        &#125;    &#125;    System.out.println(\"等概率准则决策结果：\"+max);&#125;\n 最小机会损失决策准则\n 定义\n最小机会损失决策策略又被称为最小遗憾值决策准则或 Savage 决策准则。首先要将收益矩阵中的各元素变换为每一 “策略—事件” 对的机会损失值（遗憾值，后悔值）。其含义是：当某一事件发生后，由于决策者没有选用收益最大的策略，而形成的损失值。\n 计算步骤\n首先计算出当发生 k 事件后，各策略的收益最大值\n\naik = max ( aik )\n\n这时各策略的机会损失值为\n\n\na'_{ik}\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n = { max ( aik ) - aik }\n\n从所有最大机会损失值中选取最小者，它对应的策略为决策策略。\n 计算公式\n\nS*k  \n\\rightarrow\n\n\n\n\n \n\n min  max \na'_{ik}\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n\n\n 计算结果（该矩阵为损失矩阵）\n\n\n\n（策略\\事件）\nE1 = 0\nE2 = 10\nE3 = 20\nE4 = 30\nE5 = 40\nmax\n\n\n\n\nS1 = 0\n0\n50\n100\n150\n200\n200\n\n\nS2 = 10\n10\n0\n50\n100\n150\n150\n\n\nS3 = 20\n20\n10\n0\n50\n100\n100\n\n\nS4 = 30\n30\n20\n10\n0\n50\n50\n\n\nS5 = 40\n40\n30\n20\n10\n0\n40 \n\\longleftarrow\n\n\n\n\n \n\n min\n\n\n\n决策结果为\n\nmin {200, 150, 100, 50, 40 } = 40\n\n对应的策略 S5 为决策策略。在分析产品废品率时，应用本决策准则就比较方便。\n 计算代码\n1234567891011121314151617181920212223242526272829303132333435363738394041/** * 最小机会损失决策 * @matrix 决策矩阵 * @row 决策矩阵行数 * @col 决策矩阵列数 */public static void savage(double[][] matrix, int row, int col)&#123;    //损失矩阵    double[][] loss = new double[row][col];    for (int j = 0; j &lt; col; j++) &#123;        double max = matrix[0][j]; //先定每一列的第一个最大        for (int i = 1; i &lt; row; i++) &#123;            if(matrix[i][j] &gt; max)&#123;                max = matrix[i][j];            &#125;        &#125;        //损失矩阵中对应位置的值 = 决策矩阵中列最大值 - 决策矩阵中对应位置值        for (int i = 0; i &lt; row; i++) &#123;            loss[i][j] = max - matrix[i][j];        &#125;    &#125;    //此时损失矩阵已经求出    double[] maxMar = new double[row];    for (int i = 0; i &lt; row; i++) &#123;        double max = loss[i][0]; //让第一个最大        for (int j = 1; j &lt; col; j++) &#123;            if(loss[i][j] &gt; max)&#123;                max = loss[i][j];            &#125;        &#125;        maxMar[i] = max;    &#125;    System.out.println(Arrays.toString(maxMar));    double min = maxMar[0];    for (int i = 0; i &lt; row; i++) &#123;        if(maxMar[i] &lt; min)&#123;            min = maxMar[i];        &#125;    &#125;    System.out.println(\"最小机会损失决策结果：\"+min);&#125;\n 折中主义准则\n 定义\n当用 min max 决策准则或 max max 决策准则来处理问题时，有的决策者认为这样它极端了。于是提出把这两种决策准则给予综合，令 a 为乐观系数，且 0 &lt; a &lt; 1。\n 计算步骤\n设 \na^i_{max}\n\n\n\n\n\n\n\n \n \n\n \n \n \n\n\n，\na^i_{min}\n\n\n\n\n\n\n\n \n \n\n \n \n \n\n\n分别表示第 i策略可能得到最大收益值与最小收益值。根据下列关系式\n\n\nH_i\n\n\n\n\n\n \n \n\n= \na*a^i_{max}\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n \n \n \n\n\n\n + \n(1-a)a*a^i_{min}\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n \n \n\n \n \n \n\n\n\n\n\n将计算出的 \nH_i\n\n\n\n\n\n \n \n\n 记在矩阵表右侧，然后选择其中的最大者，对应的策略即为决策策略\n 计算公式\n\nS*k  \n\\rightarrow\n\n\n\n\n \n\n max { Hi  }\n\n 计算结果（设 a = 1/3）\n\n\n\n（策略\\事件）\nE1 = 0\nE2 = 10\nE3 = 20\nE4 = 30\nE5 = 40\n\nH_i\n\n\n\n\n\n \n \n\n\n\n\n\n\nS1 = 0\n0\n0\n0\n0\n0\n0\n\n\nS2 = 10\n-10\n50\n50\n50\n50\n10\n\n\nS3 = 20\n-20\n40\n100\n100\n100\n20\n\n\nS4 = 30\n-30\n30\n90\n150\n150\n30\n\n\nS5 = 40\n-40\n20\n80\n140\n200\n40 \n\\longleftarrow\n\n\n\n\n \n\n max\n\n\n\n决策结果为\n\nmin {0, 10, 20, 30, 40 } = 40\n\n对应的策略 S5 为决策策略。\n 计算代码\n1234567891011121314151617181920212223242526272829303132/** * 折中主义决策 * @matrix 决策矩阵 * @row 决策矩阵行数 * @col 决策矩阵列数 * @a 乐观系数 */public static void eclecticism(double[][] matrix, int row, int col,double a)&#123;    double[] H = new double[row];    for (int i = 0; i &lt; row; i++) &#123;        double max = matrix[i][0]; //让第一个最大        double min = matrix[i][0]; //让第一个最小        for (int j = 1; j &lt; col; j++) &#123;            if(matrix[i][j] &gt; max)&#123;                max = matrix[i][j];            &#125;            if(matrix[i][j] &lt; min)&#123;                min = matrix[i][j];            &#125;        &#125;        //对运算结果四舍五入,保留两位小数        H[i] = new BigDecimal(a*max + (1-a) * min).setScale(2, RoundingMode.UP).doubleValue();    &#125;    System.out.println(Arrays.toString(H));    double max = H[0];    for (int i = 0; i &lt; row; i++) &#123;        if(H[i] &gt; max)&#123;            max = H[i];        &#125;    &#125;    System.out.println(\"折中主义准则决策结果：\"+max);&#125;\n 总结\n在不确定型的决策中是因人、因地、因时选择决策准则的，但是在实际中当决策者面临不确定型决策问题时，首先是获取有关各事件发生的信息。使不确定型决策问题转化为风险决策。下篇将讨论风险决策。\n 参考\n\n运筹学（第4版）本科版\n\n","plink":"https://dmego.me/2018/11/04/decision-making-under-uncertainty/"},{"title":"Mybatis 逆向工程中使用 Mysql 8.0 版本驱动遇到的问题","date":"2018-10-10T06:49:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.541Z","content":"\n \n\n\n 前言\n今天在使用8.0.12版的 mysql 驱动时遇到了各种各样的坑，在使用 JDBC 连接上遇到的问题可以参考我的上一篇博客。我在使用 mybatis 逆向工程生成各种 mapper，pojo，dao时，遇到了一个困惑我好几个小时的错误，这个错误是\n1Result Maps collection already contains value for BaseResultMap\n产生这个错误可能有各种原因。但是这里我只说我的原因及解决过程。\n 初步探索\n我在网上查阅了大量的博客文章，对于产生这类错误的原因最多的是：生成了多次 mapper，dao以及pojo 文件。也就是多次运行了生成这些文件的方法。造成XXXmapper.xml中出现了重复的resultmap。但是我这里把这些文件删除后，再重新生成还是会报这个错。所以肯定不是多次生成的问题。\n于是我打开了出现问题的那个Mapper.xml文件，搜索BaseResultMap发现其作为resultMap的id居然出现了三次，还有很多其他的sql标签的id也有很多重复的。我将这些重复的都删除，再次运行，成功了，没有出现错误。而且利用这些生成的 mapper做后面的功能也没有任何问题。这就非常奇怪，为什么会多生成这些代码呢，我继续在网上找相关的文章。\n 深入探索\n好不容易找到一篇博客中提到 ：升级到 mysql 8.0 驱动后的使用 mybatis 逆向工程生成的文件或不一样，具体的怎么不一样也没有说。看到这里，我猜会不会是驱动版本造成的，于是我将 pom.xml里的 mysql 驱动版本调整到了 5.1.10。删干净文件，再次生成后，发现之前出错的那个 mapper.xml里的 以 BaseResultMap作为 id 的 resultMap 只有一个了，其他的resultMap中id 也是唯一的。为了检验这次生成的到底有没有用。我启动 Tomact运行程序。发现正常启动，后续的功能也没有问题。\n 最终解决\n但是如果使用 5.0 版本的驱动连接 mysql 8.0 在项目中可能会遇到难以预料的问题，所以我并没有就此将驱动版本改变。我继续在网上通过换各种关键词来搜寻解决方案。几个小时过去了，还是没有任何结果。最后被迫去看了 [MyBatis Generator]的官方英文文档。中文文档已经看过了，没有找到相关的内容。在阅读英文文档中，我在Database Specific Information(使用注意事项)下面的mysql使用注意事项中似乎找到了相关的内容。其原内容如下：\n\nIf you are using version 8.x of Connector/J you may notice that the generator attempts to generate code for tables in the MySql information schemas (sys, information_schema, performance_schema, etc.) This is probably not what you want! To disable this behavior, add the property “nullCatalogMeansCurrent=true” to your JDBC URL.\n\n\nFor example:\n\n1234&lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost/my_schema&quot;         userId=&quot;my_user&quot; password=&quot;my_password&quot;&gt;     &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=true&quot; /&gt; &lt;/jdbcConnection&gt;\n上面的英文文档翻译过来就是:\n\n如果您使用的是Connector / J的8.x版，您可能会注意到生成器尝试为MySql信息模式（sys，information_schema，performance_schema等）中的表生成代码。这可能不是您想要的！ 要禁用此行为，请将属性“nullCatalogMeansCurrent = true”添加到JDBC\n\n的确，我发现使用 8.0 版的驱动比使用 5.0 版时不仅mapper.xml文件中多生成了好多代码，而且还多生成了一个xxxWithBLOBs的pojo文件。虽然还是不太理解上面说的问题，但是我还是添加 nullCatalogMeansCurrent 属性。然后重新生成了相关的mapper，pojo，dao。打开之前出现问题的mapper.xml文件，和使用 5.0 版的驱动生成的代码一样，以 BaseResultMap作为 id 的 resultMap 只有一个了。再次启动 Tomact，成功启动，没有任何问题，测试其他业务功能，也没有任何问题。\n 后记\n下面是我找到的相关问题的帖子或博客，虽然没有解决我问题，但是也可能会遇到，这里记录一下\n\nmysql8.0逆向工程遇到的坑\nMyBatis Generator mysql8.0版本的连接的注意点\nmybatis(错误一) 项目启动时报“Result Maps collection already contains value forxxx”的解决方案\nmybatis.generator配上最新的mysql 8.0.11的一些坑\nmysql8.0 mybatis逆向工程 mybatis-generator\n\n","plink":"https://dmego.me/2018/10/10/mysql8-mybatis-geneator/"},{"title":"JDBC连接Mysql数据库出现的问题汇总","date":"2018-10-10T04:10:20.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.529Z","content":"\n\n\n\n 前言\n最近安装了一个 mysql 8.0 版本的数据库，在程序中连接的时候可谓是状况不断。之前也会遇到一些问题，这里就对使用 JDBC 连接mysql 会出现的问题做一个汇总。\n在此之前说明一下环境：\n\n\n开发工具：IDEA\n\n\nmysql版本： 8.0.12 for Win64 on x86_64 (MySQL Community Server - GPL)\n\n\nmysql驱动包：8.0.12\n\n\n 驱动包URL 的改变\n 异常信息\n\nLoading class com.mysql.jdbc.Driver. This is deprecated. The new driver class is com.mysql.cj.jdbc.Driver. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.\n\n 原因\n通过异常我们可以发现，新的驱动url是com.mysql.cj.jdbc.Driver,经过在网上查阅资料发现，从 mysql6开始，驱动包开始使用新的驱动 url。如果使用旧的 5.0 版本的驱动包，则不用驱动URL，但是如果使用旧的驱动可能会出现一些意想不到的问题。所以还是建议将驱动包升级，然后改变 驱动 URL 的值。\n 解决方法\n将驱动 URL 由com.mysql.jdbc.Driver 换成 com.mysql.cj.jdbc.Driver\n SSL 警告\n 警告信息\n\nEstablishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.\n\n 原因\n对警告信息翻译如下。\n\n不建议在没有服务器身份验证的情况下建立SSL连接。根据MySQL 5.5.45+，如果未设置显式选项，则默认情况下必须建立5.6.26+和5.7.6+要求的SSL连接。对于不使用SSL的现有应用程序，ValuyServer证书属性设置为“false”。您需要通过设置useSSL=false来显式禁用SSL，或者设置useSSL=true并提供用于服务器证书验证的信任库`。\n\n 解决方法\n一般在开发中基本不需要使用 SSL 连接，在连接字符串后添加useSSL=false参数就行。但是如果真的有 SSL 连接的需要，则在驱动 URL 后添加useSSL=true参数。\n1jdbc:mysql://localhost:3306/dbname?characterEncoding=UTF-8&amp;useSSL=false\n 时区问题\n 异常信息\n\njava.sql.SQLException: The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.\n\n 原因\n同样也是由于版本升级后，新的版本数据库和系统之间有了时区差异，需要指定时区serverTimezone\n 解决方法\n\n\n连接字符串后添加参数&amp;serverTimezone=GMT%2B8，最终连接字符串如下：\n1jdbc:mysql://localhost:3306/dbname?characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8\n\n\n修改数据库时间。先通过命令行连上数据库，依次输入命令及其输出如下\n1234567891011mysql&gt; show variables like &quot;%time_zone&quot;;+------------------+--------+| Variable_name    | Value  |+------------------+--------+| system_time_zone |        || time_zone        | SYSTEM |+------------------+--------+2 rows in set, 1 warning (0.04 sec)mysql&gt; set global time_zone=&quot;+8:00&quot;;Query OK, 0 rows affected (0.01 sec)\n\n\n XML 配置文件中 &amp; 的转义\n 异常信息\n\norg.mybatis.generator.exception.XMLParserException: XML Parser Error on line 16: 对实体 “useSSL” 的引用必须以 ‘;’ 分隔符结尾。\n\n 原因\n这是我在使用mybatis generator时出现的错误。当时我想在连接字符串后加上useSSL参数，但是由于在 XML 文件中，&amp;是被禁止的，所以需要使用 &amp;的时要用它的转义&amp;amp;来代替。\n 解决方法\n将连接字符串中的 &amp;符号改成&amp;amp;\n 详细连接字符串参考\n1jdbc:mysql://127.0.0.1:3306/dbname?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;verifyServerCertificate=false&amp;autoReconnct=true&amp;autoReconnectForPools=true&amp;allowMultiQueries=true\n当然如果是使用 XML 作为配置文件，需要将 连接字符串中的  &amp;符号改成&amp;amp;\n","plink":"https://dmego.me/2018/10/10/java-connect-mysql-error/"},{"title":"Redis系列(二):Redis的数据类型及命令操作","date":"2018-10-05T15:30:11.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.533Z","content":"\n\n\n\n Redis 中常用命令\nRedis 官方的文档是英文版的，当然网上也有大量的中文翻译版,例如:Redis 命令参考。这里只列举常用到几个基本命令。\n\n\n\n命令\n行为\n\n\n\n\nset key value\n设置 key 值为 value\n\n\nget key\n读取 key 的值\n\n\ndel key\n删除 key\n\n\nexpire key seconds\n设置 key 的生存时间（seconds 秒后自动删除）\n\n\nttl key\n查看 key 剩余生存时间\n\n\nexists key\n判断 key 是否存在\n\n\nping\n测试与服务端是否联通\n\n\nkeys *\n匹配数据库中所有 key\n\n\ndbsize\n查询当前数据库中 key 的数量\n\n\ninfo\n返回关于 Redis 服务器的各种信息和统计数值\n\n\nflushdb\n清空当前数据库中的所有 key\n\n\nflushall\n清空整个 Redis 服务器的数据( 删除所有数据库的所有 key ）\n\n\nquit\n请求服务器关闭与当前客户端的连接( 断开连接 )\n\n\n\n Redis数据类型简介\n\n\n\n数据类型\n存储的值\n读写能力\n\n\n\n\nString\n字符串，整数或浮点数\n对字符串或一部分字符串执行操作；对整数进行自增和自减操作等\n\n\nHash\n包含键值对的无序散列表\n对单个 元素进行增、删、改；获取所以的键值对等\n\n\nList\n链表上的节点字符串元素\n推入、弹出元素；修剪、查找、移除元素等\n\n\nSet\n各不相同的字符串元素\n对单个 元素进行增、删、改；计算集合 交，并补集等\n\n\nSorted Set\n带分数的有序集合\n对单个 元素进行增、删、改；按照分数范围查元素等\n\n\n\n 字符串类型（String）\n redis string 介绍\n虽然 redis 是用 C 编写的，但是在 redis 中没有使用 C 语言的字符串，而是自定义了一个数据结构叫 SDS (simple dynamic string) ——简单动态字符串。是可以修改的，类似java中的 ArrayList。同时它也不像 C 中的字符串那样遇到 \\0字符就认为字符串结束，他不会对存储进去的字符串数据进行任何处理，因此 redis 中的字符串也是二进制安全的。\nredis 的 string 类型可以包含任意数据，包括图片等二进制或者序列化的对象等。单个 value 的值最大上限为 1G字节。\n 纯字符串操作命令\n注：#后面是命令的注释，不可执行\n12345678910127.0.0.1:6379&gt; set key1 'hello redis' # 存值OK127.0.0.1:6379&gt; get key1 # 取值\"hello redis\"127.0.0.1:6379&gt; getset key1 redis # 将给定key1的值设为redis，并返回key1的旧值(old value)\"hello redis\"127.0.0.1:6379&gt; get key1\"redis\"127.0.0.1:6379&gt; del key1 # 删除 key1(integer) 1\n 整数自增自减操作命令\n1234567891011121314127.0.0.1:6379&gt; set key2 10 # 存入一个值为10的整数字符串OK127.0.0.1:6379&gt; incr key2 # 自增(integer) 11127.0.0.1:6379&gt; incr key2 # 自增(integer) 12127.0.0.1:6379&gt; incrby key2 5 # 自增指定数值 -- 5(integer) 17127.0.0.1:6379&gt; decr key2 # 自减(integer) 16127.0.0.1:6379&gt; decr key2 # 自减(integer) 15127.0.0.1:6379&gt;  decrby key2 5 # 自减指定数值 -- 5(integer) 10\n 其他命令\n1234567891011121314127.0.0.1:6379&gt; set key1 redisOK127.0.0.1:6379&gt; append key1 hello # 将 hello 追加到 key1 原来的值的末尾,放回追加后字符串长度(integer) 10127.0.0.1:6379&gt; get key1\"redishello\"127.0.0.1:6379&gt; strlen key1 # 返回 key1 所储存的字符串值的长度(integer) 10127.0.0.1:6379&gt; mset key1 v1 key2 v2 key3 v3 # 批量同时设置一个或多个 key-value 对OK127.0.0.1:6379&gt; mget key1 key2 key3 # 返回所有(一个或多个)给定 key 的值1) \"v1\"2) \"v2\"3) \"v3\"\n 应用场景\n\n商品编号，订单号采用string 的递增数字特性生成\n\n 散列类型（Hash）\n redis hash介绍\nhash 叫散列类型。等价于Java 中的 HashMap。但是在 redis 中 hash 的 key 必须是 string 类型。不支持其他类型。这个特性非常适合存储对象。因为一个对象可以有很多属性，存储起来就是键值对形式的。在 Reids 中，每个 Hash 可以存储多达 4 亿个键值对。\n\n 相关操作命令\n123456789101112131415161718192021222324252627282930127.0.0.1:6379&gt; hset user name zhangsan # 使用 hset 为 user 添加一个键值对 name = zhangsan(integer) 1127.0.0.1:6379&gt; hset user age 18 # 使用 hset 为 user 添加一个键值对 age = 18(integer) 1127.0.0.1:6379&gt; hget user name # 使用 hget 获取 user 中键为 name 的值\"zhangsan\"127.0.0.1:6379&gt; hget user age # 使用 hget 获取 user 中键为 age 的值\"18\"127.0.0.1:6379&gt; hgetall user # 使用 hgetall 获取 user 中所有的键值对1) \"name\"2) \"zhangsan\"3) \"age\"4) \"18\"127.0.0.1:6379&gt; hmset user name lisi age 20 # 使用 hmset 为 user 批量添加键值对OK127.0.0.1:6379&gt; hmget user name age # 使用 hmget 批量获取 user 中键的值1) \"lisi\"2) \"20\"127.0.0.1:6379&gt; hdel user name# 使用 hdel 删除 user 一个（或多个）键值对(integer) 1127.0.0.1:6379&gt; hexists user name # 使用 hexists 判断 user 中 name 元素是否存在(integer) 0127.0.0.1:6379&gt; hexists user age # 使用 hexists  user 中 age 元素是否存在(integer) 1127.0.0.1:6379&gt; hkeys user # 使用 hkeys 只获得 user 中的字段名1) \"age\"127.0.0.1:6379&gt; hvals user # 使用 hvals 只获得 user 中的字段值1) \"20\"127.0.0.1:6379&gt; hlen user # 使用 hlen 获得  user 中字段（键值对）数量(integer) 1\n 其他特性\nRedis 中的 Hash 结构有扩容和缩容特性，扩容主要应用在当 hash 内部比较拥挤的时候，容易产生 hash 碰撞，这时需要扩容 hash 。申请新的两倍大小的数组；而缩容与扩容恰恰相反，虽然原理一样，但是申请的新数组要比旧的小一倍。\n 应用场景\n\n保存大量的对象数据\n\n 列表类型（List)\n redis list介绍\n在 java 中，列表类型有两种，一种是 ArrayList，实现方式是数组，所以根据索引查询数据速度快，而插入或者删除某个元素涉及到位移操作，会比较慢；另一种是 LinkedList，实现方式是双向链表（double linked list），每个元素都记录着前后元素的指针。所以在插入或删除某个元素时只需要更改该元素的前后指针指向就行，非常快，但是在查询上需要从头索引，特别是当数据量大的时候，索引起来还是比较慢的。\n在 Redis 中的 List 类型，其内部使用的是双向链表实现的,所以它具有双向链表具有的相关特性。其常用操作就是向列表两端添加或删除元素。这使得 List 既可以当做栈（先进后出）来使用，也可以当做队列（先进先出）来使用。\n 相关操作命令\n12345678910111213141516171819202122232425262728127.0.0.1:6379&gt; lpush list 1 2 3 4 # 使用 lpush 将 1 2 3 4 依次插入到 list 的左端(integer) 4127.0.0.1:6379&gt; rpush list 5 6 7 8 # 使用 rpush 将 5 6 7 8 依次插入到 list 的右端(integer) 8127.0.0.1:6379&gt; lrange list 0 -1 # 使用 lrange 获取 指定区间上所有值（0 -1 表示获取全部）1) \"4\"2) \"3\"3) \"2\"4) \"1\"5) \"5\"6) \"6\"7) \"7\"8) \"8\"127.0.0.1:6379&gt; lpop list # 使用 lpop 弹出 list 左端的一个值，并返回弹出的值\"4\"127.0.0.1:6379&gt; lpop list \"3\"127.0.0.1:6379&gt; rpop list # 使用 rpop 弹出 list 右端的一个值，并返回弹出的值\"8\"127.0.0.1:6379&gt; rpop list\"7\"127.0.0.1:6379&gt; lrange list 0 -11) \"2\"2) \"1\"3) \"5\"4) \"6\"127.0.0.1:6379&gt; llen list # 使用 llen 获取 list 中元素个数(integer) 4\n 应用场景\n\n商品，博客，文章下面的评论列表。\n\n 集合类型（Set）\n redis set 介绍\nredis 中的 set 类型和 java 中的 HashSet 类似，其底层都是用HashMap 实现的，只不过所有的 value 都指向同一个对象。在 set 中，没有重复的元素。并且没有顺序。其常用的操作就是向集合中加入或删除一个元素、判断某个元素是否在集合中。另外 redis 还提供了多个集合之间的 交集、并集、差集的运算。\n 相关操作命令\n1234567891011121314127.0.0.1:6379&gt; sadd set a b c 1 2 3  # 使用 sadd 将 a b c 1 2 3 添加到 set 集合中(integer) 6127.0.0.1:6379&gt; sadd set a b 2  # 添加重复元素，返回成功添加 0 个，说明 set 中元素不重复(integer) 0127.0.0.1:6379&gt; srem set a b 1  # 使用 srem 删除 set 集合中的 a b 1 三个元素(integer) 3127.0.0.1:6379&gt; smembers set  # 使用 smembers 获取 set 集合中所以元素1) \"2\"2) \"c\"3) \"3\"127.0.0.1:6379&gt; sismember set a  # 使用 sismember 判断 a 是否在 set 集合中(integer) 0127.0.0.1:6379&gt; sismember set c  # 使用 sismember 判断 c 是否在 set 集合中(integer) 1\n 集合间的相关运算\n 集合的并集运算 A ∪ B\n\n12345678910127.0.0.1:6379&gt; sadd seta 1 2 3(integer) 3127.0.0.1:6379&gt; sadd setb 3 4 5(integer) 3127.0.0.1:6379&gt; sunion seta setb # 使用 sunion 计算 seta 和 setb 的并集1) \"1\"2) \"2\"3) \"3\"4) \"4\"5) \"5\"\n 集合的交集运算 A ∩ B\n\n123456127.0.0.1:6379&gt; sadd seta 1 2 3(integer) 3127.0.0.1:6379&gt; sadd setb 3 4 5(integer) 3127.0.0.1:6379&gt; sinter seta setb # 使用 sinter 计算 seta 和 setb 的交集1) \"3\"\n 集合的差集运算 A - B\n\n12345678910127.0.0.1:6379&gt; sadd seta 1 2 3(integer) 3127.0.0.1:6379&gt; sadd setb 3 4 5(integer) 3127.0.0.1:6379&gt; sdiff seta setb # 使用 sdiff 计算 seta - setb (属于seta 但不属于 setb)1) \"1\"2) \"2\"127.0.0.1:6379&gt; sdiff setb seta # 使用 sdiff 计算 setb - setb (属于setb 但不属于 seta)1) \"4\"2) \"5\"\n 有序集合类型 (sorted set)\n redis sorted set介绍\nSortedSet(zset)是 redis 提供的一个非常特别的数据结构，它在集合的基础上为每一个元素都关联了一个分数，这相当于 java 中的 Map&lt;String,Double&gt;，可以给每一个元素赋予一个score权重。另一方面又像TreeSet，内部的元素会按照权重score进行排序。\n 相关操作命令\n12345678910111213141516171819202122232425262728293031323334353637383940127.0.0.1:6379&gt; zadd board 81 java 75 python 90 c++ # 使用 zadd 增加一到多个value/score对，score 放在前面(integer) 3127.0.0.1:6379&gt; zscore board java # 使用 zscore 获取 java 的 score\"81\"127.0.0.1:6379&gt; zrange board 0 -1 # 使用 zrange 获取指定区间（0 -1 表示全部）上的降序排名1) \"python\"2) \"java\"3) \"c++\"127.0.0.1:6379&gt; zrange board 0 -1 withscores # 带上 winthscores 可以一并获取元素的 score1) \"python\" 2) \"75\"3) \"java\"4) \"81\"5) \"c++\"6) \"90\"127.0.0.1:6379&gt; zrevrange board 0 -1 withscores # 使用 zrevrange 获取指定区间（0 -1 表示全部）上的升序排名1) \"c++\"2) \"90\"3) \"java\"4) \"81\"5) \"python\"6) \"75\"127.0.0.1:6379&gt; zrangebyscore board -inf +inf withscores # 使用 zrangebyscore 获取 负无穷（-inf）到 正无穷（+inf）区间上所以元素的降序排名1) \"python\"2) \"75\"3) \"java\"4) \"81\"5) \"c++\"6) \"90\"127.0.0.1:6379&gt; zrevrangebyscore board +inf -inf withscores # 使用 zrevrangebyscore 获取正无穷（+inf）到 负无穷（-inf）区间上所以元素的升序排名 1) \"c++\"2) \"90\"3) \"java\"4) \"81\"5) \"python\"6) \"75\"127.0.0.1:6379&gt; zcard board # 使用 zcard 计算 board 集合的元素个数(integer) 3127.0.0.1:6379&gt; zrem board java python # 使用 zrem 删除 board 集合中的一个或多个元素 (integer) 2\n 应用场景\n\n商品销售，软件下载等各种排行榜\n\n 参考\n\n\n通俗易懂的Redis数据结构基础教程\n\n\n[Redis基础：基本介绍、redis的应用场景、五种数据类型、持久化操作、主从模式]\n\n\nRedis 命令参考\n\n\n","plink":"https://dmego.me/2018/10/05/learn-redis-2/"},{"title":"Redis系列(一):Redis的简介与安装","date":"2018-10-04T02:02:31.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.533Z","content":"\n\n\n\n 什么是 Redis\nRedis 是一个使用ANSI C 编写的开源、支持网络协议、基于内存、可选持久性的键值对数据库,它是一个NOSQLnot only sql)数据库,也就是常说的非关系型数据库。从 2005 年开始，Redis 的开发由 Redis Labs 赞助，之前一直被 Pivotal 和 VMware 先后赞助。根据月度排行网站 DB-Engines.com 的数据显示，Redis 是最流行的键值对数据库。\n Redis 应用场景\n主要用于数据量大，并发量高的情况下\n\n数据缓存（页面具体数据），页面缓存（商品内容，新闻内容）\n分布式集群中架构中的Session分离\n应用排行榜，在线好友列表等\n任务队列，例如抢购秒杀等\n\n Redis 的安装\nRedis 是不支持 windows 版本的，因为其在 windows 下的效率非常低，但是Microsoft 开放技术小组开发和维护了一个针对 windows 版的 Redis,但是从项目记录来看已经有两年没更新了。\n从官网可以看到，目前最新稳定版为 Redis 4.0.11。此次安装环境选择 centOS ,方式为源码编译安装，所以我们需要有gcc环境，先执行下面的命令安装 gcc\n1yum install gcc-c++ -y\n然后将最新稳定版的源码包下载下来\n1wget http://download.redis.io/releases/redis-4.0.11.tar.gz\n解压到/usr/local/目录下\n1tar -zxvf redis-4.0.11.tar.gz -C /usr/local\n进入Redis 目录进行编译\n12cd /usr/local/redis-4.0.11make\n编译完成后，安装到指定目录，例如:/usr/local/redis-6379（也可以直接命令6379，因为可以在同一台机器上运行多个 redis 服务，所以一般以运行端口命名）\n12cd /usr/local/redis-4.0.11make PREFIX=/usr/local/redis-6379 install\n安装完成之后，我们还需要拷贝一份 redis 的配置文件——redis.conf 到安装路径下面，redis.conf 在 redis 的源码目录下\n12cd /usr/local/redis-4.0.11cp redis.conf /usr/local/redis-6379/bin/\n\n\n\n\n文件名\n说明\n\n\n\n\nredis-server\nredis 服务器\n\n\nredis-cli\nredis 命令行客户端\n\n\nredis-benchmark\nredis 性能测试工具\n\n\nredis-check-aof\naof 文件修复工具\n\n\nredis-check-dump\nrub 文件检查工具\n\n\n\n Redis 的启动\n 前端模式启动\n如果在bin目录下直接运行 ./redis-server将以前端模式启动,启动成功界面如下所示\n\n这种方式启动后，我们不能关闭该窗口，关闭该窗口后 redis 服务将会停止。如果想要使用 redis 需要再开一个窗口。进入到bin目录，运行./redis-cli命令，开启一个 redis 客户端连上 redis 服务。\n 后端模式启动\n我们进入bin目录，先给之前拷贝过来的redis.conf配置文件赋予权限\n12cd /usr/local/redis-6379/bin/chmod 777 redis.conf\n然后打开 redis.conf配置文件，修改启动参数daemonize为yes，以后端方式启动。如果找不到daemonize,可以使用 vim打开文件后，使用:/daemonize来查找，找到后修改no为yes，然后wq保存退出。此时，我们就可以使用如下命令以后端方式启动 redis\n1./redis-server redis.conf\n启动后可以使用ps -aux|grep redis命令来查看是否启动成功\n\n如上图所示,默认启动端口为 6379\n Redis 的停止\n如果我们强行停止 Redis 的进程可能会导致 Redis 持久化的数据丢失，所以正确停止 Redis 的方式应该是使用 ./redis-cli shutdown命令。\n Redis 客户端的连接和使用\n在bin目录下的redis-cli就是 redis 的客户端，执行./redis-cli命令将会连接到 redis 服务器。连接成功后，我们可以使用set key1 111来保存一个值为111名为key1的键值对。使用get key1命令读取key1的数据\n\n 使用Redis 可视化工具\n如果想要在Windows、Mac 或Linux 图像界面下可视化操作 Redis ，可以使用 Redis Desktop Manager，但是现在对于Windows 和 Mac 不提供下了，不过在网上还能搜到下载的链接。\n\n另外还有几款开源的可视化工具也不错，例如：Redis Client、Redis Studio，但是都已经停止更新维护了。\n","plink":"https://dmego.me/2018/10/04/learn-redis-1/"},{"title":"为什么说java中只有值传递","date":"2018-08-27T17:59:31.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.529Z","content":" 前言\n这几天在整理java基础知识方面的内容，对于值传递还不是特别理解，于是查阅了一些资料和网上相关博客，自己进行了归纳总结，最后将其整理成了一篇博客。\n 值传递\n值传递是指在调用函数时将实际参数复制一份传递给形参，这样在函数中对形参的修改将不会影响到实际参数的值。\n 引用传递\n引用传递是指在调用函数时将实际参数的地址直接传递到形参，那么在函数中对参数所进行的修改，将会影响到实际参数的值。\n我们可以使用一段程序来验证Java中只有值传递\n12345678910111213141516171819202122232425262728293031323334353637/** * 验证java中只有值传递 * Dmego 2018-8-27 */class User&#123;        private String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;public class TestValue &#123;    public static void change(User user2,int a2)&#123;        System.out.println(\"改变之前：\"+user2.getName()+\",a2=\"+a2);                user2.setName(\"李四\"); //改变 user2 的 name 值        a2 = 10; //改变 a2 的值        System.out.println(\"改变之后：\"+user2.getName()+\",a2=\"+a2);                user2 = new User(); //将 user2 重新指向一个新对象        user2.setName(\"王五\");        System.out.println(\"重新指向一个新对象后：\"+user2.getName());    &#125;    public static void main(String[] args)&#123;        User user1 = new User();        user1.setName(\"张三\"); //初始化 user1 的 name 为张三        int a1 = 5; //初始化 a1 的值为 5        change(user1,a1); //调用方法验证传值方式        System.out.println(\"调用方法后：\"+user1.getName()+\",a1=\"+a1);    &#125;&#125;\n运行这段程序，输出结果为：\n1234改变之前：张三,a2=5改变之后：李四,a2=10重新指向一个新对象后：王五调用方法后：李四,a1=5\n 结果分析\n\n下面我们以上图为辅助，来分析这段程序，首先我们定义了一个User类，然后在测试类中实例化了一个User对象，名为user1，并且为其赋值name = '张三'，此时在内存中如图1所示，实例化一个对象相当于在堆中开辟了一块内存，内存地址为017，此时这个对象的引用为user1,内存地址为001,它保存了该对象在内存中的地址，也就是指向了该对象。接下了，我们调用方法change()，来尝试改变user1的name值以此验证java中的传值方式。\n我们将user1作为实参传给change()方法，形参user2来接受这个实参，在这里就体现出了两种传参方式的不同。如果是按值传递，那么就像定义的那样，如图2所示，user2是user1的一份副本，也就是说在传递参数时，将user1（本身是一个对象的引用），复制了一份，名为user2，它同样也是一个对象的引用，并且user1和user2此时指向同一个对象。而如果是引用传递，也如同定义的那样，如图5所示,在传递参数时，是直接将user1传递给了形参，只是换了一个名字叫做user2,但是本质上user1和user2其实是同一个。它是一个对象的引用。\n接着来分析输出的结果，不管是按值传递还是引用传递，第1行输出的结果一定都是张三，因为都是指向同一个对象。对于第2行输出，我们还是无法判断是哪种方式，因为都是改变同一个对象，值也会改变；关键在于第3行输出和第4行输出，此时，我们将user2重新指向了一个新的对象，并且为这个对象赋值name = '王五'，如果是引用传递的方式，那么user1同样也会改变指向，指向新的这个对象，最后一行调用方法之后输出的结果将会和第3行一样是王五，但是事实输出的是李四，这表明user1和user2其实并不是同一个。真实的调用过程如 图2~图4所示，这样才会使得user2指向一个新的对象后，user1指向的对象并没有改变，还是原来那个对象。\n对于基本类型的参数来说,a1的值最后没有改变，说明在执行方法时，a2是a1的一个副本。对于引用类型的参数来说，例如User对象，在调用方法时，实际上是将其引用user1作为实际参数，那么传递给形参的将是该引用的一份副本引用user2，虽然说这是两份引用（好比a1与a2的关系）。但是却指向同一个对象，所有的操作也都是对这同一个对象而言的。\n最后举一个例子来形象的说明这一切，假如你有一把你房间的钥匙，并且在上面刻上了你的名字，这个过程好比给一个int类型的a1初始化值为5。你的朋友和你关系非常好，想要你房间的钥匙，此时你并没有直接把你的钥匙给他，而是复制了一把新的钥匙，这个钥匙也能开你的房间的门。而你的朋友在这把新钥匙上刻上了他的名字。这个过程就好比调用change()方法，把a1复制了一份赋值给a2,此时修改a2和a1没有任何关系，你朋友在新钥匙上刻他名字也不会影响你手上那把原始的钥匙。关键是这两把钥匙都能开你的房间，就好比user1和user2都指向同一个对象。此时你朋友用这把新钥匙打开了你的房间，将你房间电视机砸了。这个过程好比改名李四。这时你拿着你的钥匙打开你房间必然会看到这样的场景——电视机被砸了。就如同调用方法后user1变成了李四。在调用方法的过程中，最后user2重新指向了一个新的对象，这就好比你的朋友将你复制给他的钥匙再次进行了加工，此时不能开你房间的门，但是能开他自己的房间，他用这把钥匙开自己的房间然后把自己的电视砸了这并不会影响到你房间的电视，也就是说最后user1的名字并不会变成王五。这就是java中的值传递。当然了，如果是引用传递，那么这个例子中从头到尾将会只有一把钥匙，最后的结果也将会不同。\n 尾声\n通过以上分析我们可以知道。Java中只有值传递这一种方式，只不过对于引用类型来说，传递的参数是对象的引用罢了。\n","plink":"https://dmego.me/2018/08/27/java-only-pass-by-value/"},{"title":"基于ubuntu16.04部署IBM开源区块链项目-弹珠资产管理(Marbles)","date":"2018-05-15T22:21:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.505Z","content":"\n\n## 前言\n本教程基本上是对Marbles项目的翻译过程. 如果英文比较好的话，建议根据官方操作说明,一步步进行环境部署。当然你也可以参考本教程在自己的主机上部署该项目。\n Marbles 介绍\n 关于 Marbles\n\n这个应用程序的基础网络是 Hyperledger Fabric，后者是一个 Linux Foundation 项目。 您可能想查阅以下操作说明来稍微了解一下 Hyperledger Fabric\n本演示旨在帮助开发人员了解链代码的基础知识以及如何使用 Fabric 网络开发应用程序\n这是一个非常简单的资产转移演示。多个用户可以创建并相互转移弹珠。\n\n\n 版本\n各种版本的 marbles 同时存在。 本版本兼容 Hyperledger Fabric v1.1x。 你可以通过检出别的分支来获取别的版本的 marble,这里演示使用的是ae4e37d分支\n 应用程序背景\n请大家集中注意力，这个应用程序将演示如何利用  Hyperledger Fabric 在许多弹珠所有者之间转移弹珠。 我们将在 Node.js 中使用一些 GoLang 代码完成此任务。 该应用程序的后端将是在我们的区块链网络中运行的 GoLang 代码。 从现在开始，这些 GoLang 代码将称为“链代码”或“cc”。 该链代码本身会创建一颗弹珠，将它存储到链代码状态中。 该链代码本身可以将数据作为字符串存储在键/值对设置中。 因此，我们将字符串化 JSON对象，以便存储更复杂的结构.\n\n弹珠的属性包括：\n\n\nID（唯一字符串，将用作键）\n颜色（字符串，CSS 颜色名称）\n尺寸（int，以毫米为单位）\n所有者（字符串）\n\n我们将创建一个用户界面，它可以设置这些值并将它们存储在区块链的账本中。 弹珠实际上是一个键值对。 键为弹珠 ID，值为一个包含（上面列出的）弹珠属性的 JSON 字符串。 与 cc 的交互是通过对网络上的一个对等节点使用 gRPC 协议来完成的。 gRPC 协议的细节由一个名为 Hyperledger Fabric Client SDK 的 SDK 处理。 请查看下图了解拓扑结构细节。\n\n 应用程序通信流\n\n1.管理员将在他们的浏览器中与我们的 Node.js 应用程序 Marbles 进行交互\n2.此客户端 JS 代码将打开一个与后端 Node.js 应用程序的 Websocket 连接,管理员与该站点交互时,客户端 JS 将消息发送到后端\n3.读取或写入账本称为提案,这个提案由 Marbles (通过SDK)构建,然后发送到一个区块链对等节点.\n4.该对等节点将与它的 Marbles 链代码容器进行通信. 链代码容器将运行/模拟该交易. 如果没有问题, 它会对该交易进行背书,并将其发回我们的Marbles程序.\n5.然后, Marbles (通过SDK)将背书后的提案发送到订购服务.订购方将来自整个网络的许多提案打包到一个区块中. 然后它将新的区块广播到网络中的对等节点\n6.最后,对等节点会验证该区块并将它写入到自己的账本中,该交易现在已经生效,所有后续读取都会反映此更改.\n\n Marbles 项目环境配置\n这里使用的是本地的 Hyperledger Fabric 网络来部署项目,如果想使用 IBM Cloud IBM Blockchain 服务来部署该项目,请参考前言中给的官方文档.\n\n注意:本教程使用的系统环境是: ubuntu16.04\n\n 设置 Chaincode(链码) 开发环境\n如果您通过本人的上一篇博客基于ubuntu16.04快速构建Hyperledger Fabric网络已经搭建好了一个 Hyperledger Fabric 网络,那么这里只需要安装 Node.js 的环境并验证环境是否正确即可,如果您没有在本地搭建 Hyperledger Fabric 网络,建议您通过上述博客先在本地构建好网络环境.\n 验证 Git 环境\n一般来说 linux 系统都是自带 Git ,如果系统里没有装,可以使用如下命令来进行安装\n1sudo apt-get install git\n安装完成后验证一下\n12$ git --versiongit version 2.7.4\n 验证 GO 环境\nGo安装安装了一组Go CLI工具，这些工具在编写链接代码时非常有用。例如，该 go build 命令允许您在尝试将其部署到网络之前检查链代码是否实际编译.\n\n验证安装环境\n\n1234$ go versiongo version go1.10 linux/amd64\n echo \n\n\n\n\n\n\n\n \n \n \n \n\nGOPATH/home/ubuntu/go\n这里的 ubuntu是我的用户名,表示我的 GOPATH  目录是我的主目录下的 go 文件夹,当然你的 GOPATH 不需要匹配上面的那个。它只是很重要的，但你必须把这个变量设置为文件系统上的有效目录.\n 安装 Node.js 环境\n首先可以先使用 node -v 和 npm -v 命令来验证系统中是否有 Node.js 环境,如果没有安装则需要使用如下命令进行安装:\n123sudo apt-get install nodejssudo apt install nodejs-legacysudo apt install npm\n安装完成之后使用 node -v 和 npm -v 命令来查看版本信息:\n1234$ node -vv4.2.6$ npm -v3.5.2\n遗憾的是通过这种方式安装的 Node.js 版本都比较低,而且并不符合我们项目的环境要求(官网文档中出现的版本为:node:v6.10.1;npm:3.10.10),为了避免因软件版本不同而引起的问题,我们还需要对 Node 以及 npm 的版本进行升级操作\n\n先配置 npm 仓库,因为国内的网络环境,直接从 npm 官方源安装软件包速度会特别慢\n\n1npm install -g nrm\n\n安装完成之后，列出可用的软件源\n\n12345678$ nrm ls* npm ---- https://registry.npmjs.org/  cnpm --- http://r.cnpmjs.org/  taobao - https://registry.npm.taobao.org/  nj ----- https://registry.nodejitsu.com/  rednpm - http://registry.mirror.cqupt.edu.cn/  npmMirror  https://skimdb.npmjs.com/registry/  edunpm - http://registry.enpmjs.org/\n\n可以切换到淘宝的源,这个速度在国内还是很快的\n\n12$ nrm use taobaoRegistry has been set to: https://registry.npm.taobao.org/\n\n安装 node 版本管理工具 n\n\n1npm install -g n\n\n通过 n 安装指定版本\n\n1n 6.10.1\n\n再次使用 node -v 命令,查看当前版本\n\n12$ node -vv6.10.1\n\n升级 npm 的版本号\n\n1npm install -g npm@3.10.10\n\n再次使用 npm -v 命令,查看当前版本\n\n12$ npm -v3.10.10\n至此,Node.js的环境就算是搭建完成了\n Hyperledger Fabric 版本切换\n官方文档中提供了三种选择,一种是不想对链码进行修改的,下面操作可以不必执行.而想要自己修改链码的而且想使用最新版本 Fabric 的可以切换到最新的分支,虽然说该项目兼容 Hyperledger Fabric v1.1x,但是出于避免出现未知的错误,建议将分支切换到文档中使用的版本ae4e37d.切换步骤命令如下\n\n将此版本与网络/ Fabric 的提交哈希匹配（前7个字符将起作用）\n\n12cd $GOPATH/src/github.com/hyperledger/fabricgit checkout ae4e37d\n如果按照我的上篇博客配置的,这里的 $GOPATH 既用户主目录下的 go 文件夹,\n\n使用git分支确认级别。它应该显示与您提供的相符的提交级别\n\n123$ git branch* (HEAD detached at ae4e37d)  release-1.1\n显示已经切换到ae4e37d分支,当前最新发布版本为1.1. 当然,你如果想知道ae4e37d分支的具体信息,可以通过如下命令查看:\n12345678910111213141516171819$ git log -pcommit ae4e37dbafe74997534ab317dec5c3f4f53b6a84Author: Gari Singh &lt;gari.r.singh@gmail.com&gt;Date:   Mon Aug 7 17:50:39 2017 -0400    FAB-5652 Prepare fabric for 1.0.2 release    - base version = 1.0.2    - prev version = 1.0.1    - is_release = false    Change-Id: Ibce2a81193b09015eef896391b0e8166d40e7102    Signed-off-by: Gari Singh &lt;gari.r.singh@gmail.com&gt;diff --git a/Makefile b/Makefileindex d1febaa..ffe51f3 100755--- a/Makefile+++ b/Makefile@@ -36,9 +36,9 @@ PROJECT_NAME = hyperledger/fabric\n通过上面的命令输出结果可以看到,该分支是基于1.0.2版本的.切换到该分支后,还需要验证结构安装\n\n打开命令提示符/终端输入一下命令\n\n12cd $GOPATH/src/github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02go build --tags nopkcs11 ./\n它应该返回没有错误/警告。您还应该看到在该目录中创建了可执行文件。\n请注意，nopkcs11标签很重要。PKCS 11是您不太可能在您的系统上使用的公钥加密标准。 请记住在开发/构建链码时使用此标志。\n对编写链码 IDE 的选择官方文档推荐了两个 Visual Studio Code 和 Atom,具体的 IDE 开发环境配置可以在网上搜索.\n 搭建一个本地的Hyperledger网络\n这里是构建一个本地的Hyperledger网络,然后测试该网络步骤过程.\n 先下载 Marbles 项目\n我们需要将 Marbles 下载到本地系统。 让我们使用 Git 通过克隆此存储库来完成该任务。 即使您计划将 Marbles 托管在 IBM Cloud 中，也需要执行这一步,运行以下命令即可\n123cd ~git clone https://github.com/IBM-Blockchain/marbles.git --depth 1cd marbles\n注意:我这里将 Marbles 克隆到了用户主目录下,你可以选择任意合适的目录\n 下载 Hyperledger Fabric 官方例子\n我们将使用 Hyperledger Fabric 例子运行本地网络。他们的代码具有 Fabric 网络的设置以及链接代码示例。我们只会使用网络设置部分。\n使用以下命令下载它们的节点示例：\n12git clone https://github.com/hyperledger/fabric-samples.gitcd fabric-samples\n如果之前没有下载各种结构组织的 Docker 镜像,那么可以使用下面的命令进行下载\n12curl -sSL https://raw.githubusercontent.com/hyperledger/fabric/release-1.1/scripts/bootstrap-1.1.0-preview.sh -o setup_script.shsudo bash setup_script.sh\n请务必通过运行以下命令或将其粘贴到您的.profile文件中，将这些二进制文件添加到PATH变量中\n\n运行命令\n\n1export PATH=\nPWD/bin:\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\nPATH\n\n若想永久将这些二进制文件添加到PATH变量中,可以加入到系统环境变量中\n\n1vim ~/.profile\n打开后在最后一行插入插入export PATH=/home/ubuntu/fabric-samples/bin:\nPATH`,这里可以先使用 `pwd` 命令来获取您本地`fabric-samples`的目录,然后将上面命令中的 `\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n这\n\n\n里\n\n\n可\n\n\n以\n\n\n先\n\n\n使\n\n\n用\n\n \n \n \n \n \n\n命\n\n\n令\n\n\n来\n\n\n获\n\n\n取\n\n\n您\n\n\n本\n\n\n地\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n的\n\n\n目\n\n\n录\n\n \n\n然\n\n\n后\n\n\n将\n\n\n上\n\n\n面\n\n\n命\n\n\n令\n\n\n中\n\n\n的\n\n \n\nPWD 换成该目录即可,最后使用 :wq 保存退出,执行下面命令刷新一下\n1source  ~/.profile\n 启动网络\n接下来，我们需要启动Fabric。运行下面的脚本来让所有的事情都发生\n12cd ./fabcarsudo ./startFabric.sh\n一两分钟后，命令提示符将返回,运行结果如下图所示\n\n现在运行该命令 docker ps 查看当前正在运行的Docker容器。您应该看到类似于以下内容的内容：\n1234567CONTAINER ID        IMAGE                                   COMMAND                  CREATED             STATUS              PORTS                                            NAMES01cdf948b39c        dev-peer0.org1.example.com-fabcar-1.0   \"chaincode -peer.add…\"   2 minutes ago       Up 2 minutes                                                         dev-peer0.org1.example.com-fabcar-1.02f79bac1371e        hyperledger/fabric-tools                \"/bin/bash\"              3 minutes ago       Up 3 minutes                                                         cli648da0074a8d        hyperledger/fabric-peer                 \"peer node start\"        3 minutes ago       Up 3 minutes        0.0.0.0:7051-&gt;7051/tcp, 0.0.0.0:7053-&gt;7053/tcp   peer0.org1.example.com868e0f78f80e        hyperledger/fabric-ca                   \"sh -c 'fabric-ca-se…\"   3 minutes ago       Up 3 minutes        0.0.0.0:7054-&gt;7054/tcp                           ca.example.com4c385bb6aa9d        hyperledger/fabric-couchdb              \"tini -- /docker-ent…\"   3 minutes ago       Up 3 minutes        4369/tcp, 9100/tcp, 0.0.0.0:5984-&gt;5984/tcp       couchdb4b9a2b2b0718        hyperledger/fabric-orderer              \"orderer\"                3 minutes ago       Up 3 minutes        0.0.0.0:7050-&gt;7050/tcp                           orderer.example.com\n\n\n如果你没有看到全部6个容器在运行，那么有些问题是错误的。在继续之前，您需要排除故障。我建议进入一个已停止的容器的日志sudo docker logs peer0（替换名称为w / e的peer0已停止）。\n\n\n如果您看到containerID already exists正在运行的Docker工具 - 组成，那么您需要删除现有的容器。该命令将删除所有容器docker rm -f $(docker ps -aq)\n\n\n 安装并实例化链代码\n很好，就快要完成了！现在，我们需要运行我们的 Marbles 链码。 请记住，链码是一个关键组件，它最终会在账本上创建我们的 Marbles 事务。 该链码是需要安装在对等节点上，然后在一个通道上实例化的 GoLang 代码。 已为您编写好该代码！ 我们只需要运行它\n 准备\n我们需要一些弹珠依赖来运行安装/实例化脚本。通过返回 Marbles 目录的根目录并输入这些命令来安装弹珠 npm 依赖关系:\n12cd ~/marblesnpm install\n重要的是安装没有错误返回（警告是好​​的）。如果你有 npm 安装错误，在继续之前你必须解决并修复这些错误\n 生成证书与密钥文件\n这是一个非常重要步骤！ 安装和实例化操作需要管理员证书和私钥。如果找不到这些文件，您将无法运行任何操作。\n\n第1步：在终端/命令提示符中更改路径到fabric-samples/fabcar目录：\n\n1cd ../fabric-samples/fabcar\n\n第2步：运行命令：\n\n1234$ node enrollAdmin.js Store path:/home/ubuntu/fabric-samples/fabcar/hfc-key-storeSuccessfully enrolled admin user \"admin\"Assigned the admin user to the fabric client ::&#123;\"name\":\"admin\",\"mspid\":\"Org1MSP\",\"roles\":null,\"affiliation\":\"\",\"enrollmentSecret\":\"\",\"enrollment\":&#123;\"signingIdentity\":\"9b6f84a7672908c0629d9b3ad0bf23437d624089061e937af0b0476ec6dec81d\",\"identity\":&#123;\"certificate\":\"-----BEGIN CERTIFICATE-----\\nMIIB8DCCAZegAwIBAgIUeQVhK98LQFSz5Dz0bt3bB9Baom8wCgYIKoZIzj0EAwIw\\nczELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh\\nbiBGcmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMT\\nE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMTgwNTE1MTA1ODAwWhcNMTkwNTE1MTA1\\nODAwWjAQMQ4wDAYDVQQDEwVhZG1pbjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IA\\nBPlS00VDvBQpsmMFUGnNzEAQd7lgpTNgEDpzJGk4/xfBuechE8cfNH6WuibJtXxh\\nsEQ4uLAlDcOAP1nfXq9oEtWjbDBqMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8E\\nAjAAMB0GA1UdDgQWBBShJWerMoKEE2u+dn08UBkGs4tWzjArBgNVHSMEJDAigCBC\\nOaoNzXba7ri6DNpwGFHRRQTTGq0bLd3brGpXNl5JfDAKBggqhkjOPQQDAgNHADBE\\nAiAmqy0J0M1aZlvuv6cDK8GjeMTMjN0V5dZIW/uBv+whtAIgCMbyQRtE+PDwsoSS\\nG40hZ4UOoNS2tvIXHRglMMHvKjs=\\n-----END CERTIFICATE-----\\n\"&#125;&#125;&#125;\n\n第3步：运行命令：\n\n123456$ node registerUser.js Store path:/home/ubuntu/fabric-samples/fabcar/hfc-key-storeSuccessfully loaded admin from persistenceSuccessfully registered user1 - secret:PfPGkGQmNgfwSuccessfully enrolled member user \"user1\"User1 was successfully registered and enrolled and is ready to intreact with the fabric network\n\n第4步：仔细检查文件夹中是否创建了一些密钥和证书文件 fabric-samples/fabcar/hfc-key-store\n第5步：接下来，我们需要验证连接配置文件中的文件路径是否与您的安装相匹配。\n\n打开你的连接配置文件&lt;marbles root&gt;/config/connection_profile_local.json。\n\n在这个JSON里找到这三个字段：\n\norganizations -&gt; x-adminCert -&gt; path\norganizations -&gt; x-adminKeyStore -&gt; path\nclient -&gt; credentialStore -&gt; path\n\n\n每个字段中 path 的值需要反映您的环境（您的目录结构）。你可以浏览这些文件夹和文件以验证它们是否存在。\n您可能需要根据您放置fabric-samples目录的位置以及密钥存储数据所在的位置来更改这些值。一旦路径有效，您可以继续。\n\n\n\n\n第6步：你完成了！将路径更改回弹珠根目录：cd ~/marbles并继续执行下面的安装链接代码说明。\n\n 安装链码\n完成之后，我们需要将链代码放到 peer 节点的文件系统中。记住 chaincode 定义了什么弹珠（资产）是我们系统交易的业务逻辑。你可以在这个目录中找到弹珠链码&lt;marbles root&gt;/chaincode/src/。这个目录下的文件就是链码文件。\n我们将使用位于scripts文件夹中的脚本install_chaincode.js。它会读取我们的弹珠配置文件和连接配置文件数据。您可以通过编辑install_chaincode.js文件来更改本项目链代码ID或版本。如果您想编辑这些文件并想要更多关于其内容的信息，请打开下面的配置和连接配置文件自述文件。如果您对默认设置没有问题，那么只需将这些文件单独保存并运行下面的命令即可。\n\n配置和连接配置文件格式帮助\n\n使用下面的命令安装弹珠链代码文件：\n1234567891011121314151617181920cd ./scriptsnode install_chaincode.js  ................#这里省略了许多输出信息..........  ......---------------------------------------info: Now we install---------------------------------------debug: [fcw] Installing Chaincodedebug: [fcw] Sending install req targets=[grpc.http2.keepalive_time=300, grpc.keepalive_time_ms=300000, grpc.http2.keepalive_timeout=35, grpc.keepalive_timeout_ms=3500, grpc.max_receive_message_length=-1, grpc.max_send_message_length=-1, grpc.primary_user_agent=grpc-node/1.10.1, _url=grpc://localhost:7051, addr=localhost:7051, , _request_timeout=90000, , _name=null], chaincodePath=marbles, chaincodeId=marbles, chaincodeVersion=v4info: [packager/Golang.js]: packaging GOLANG from marblesdebug: [fcw] Successfully obtained transaction endorsement---------------------------------------info: Install done. Errors: nope---------------------------------------\n出现上述输出结果,说明链码安装成功\n 实例化链码\n接下来我们需要实例化链码。这会让您的 channel(通道) 启动弹珠链码mychannel。一旦完成，我们准备使用区块链网络来记录我们的系统(Marbels)活动。使用下面的命令完成实例化:\n123456789101112131415161718$ node instantiate_chaincode.js    ................#这里省略了许多输出信息..........  ......---------------------------------------info: Now we instantiate---------------------------------------debug: [fcw] Instantiating Chaincode peer_urls=[grpc://localhost:7051], channel_id=mychannel, chaincode_id=marbles, chaincode_version=v4, cc_args=[12345], ssl-target-name-override=null, pem=null, grpc.http2.keepalive_time=300, grpc.keepalive_time_ms=300000, grpc.http2.keepalive_timeout=35, grpc.keepalive_timeout_ms=3500debug: [fcw] Sending instantiate req targets=[grpc.http2.keepalive_time=300, grpc.keepalive_time_ms=300000, grpc.http2.keepalive_timeout=35, grpc.keepalive_timeout_ms=3500, grpc.max_receive_message_length=-1, grpc.max_send_message_length=-1, grpc.primary_user_agent=grpc-node/1.10.1, _url=grpc://localhost:7051, addr=localhost:7051, , _request_timeout=90000, , _name=null], chaincodeId=marbles, chaincodeVersion=v4, fcn=init, args=[12345], 0=214, 1=155, 2=127, 3=34, 4=197, 5=82, 6=208, 7=191, 8=141, 9=140, 10=57, 11=113, 12=46, 13=90, 14=76, 15=231, 16=170, 17=118, 18=197, 19=137, 20=186, 21=212, 22=64, 23=33, _transaction_id=d550ed194a2d798f2a6c2924c0302fdc6323fba2835e128f3dc541f1b6754525debug: [fcw] Successfully obtained transaction endorsementdebug: [fcw] Successfully ordered instantiate endorsement.---------------------------------------info: Instantiate done. Errors: nope---------------------------------------\n出现上述输出结果,说明实例化链码成功\n 运行 Marble 项目\n通过上述操作,我们所有的环境都已经配置完成了,接下来就是运行本项目\n 安装依赖\n打开命令提示符/终端并导航到 Marbles 目录,并执行下面的几个命令:\n123cd ~/marblessudo npm install gulp -gsudo npm install\n安装依赖成功后,并且没有错误返回（警告是好​​的）.如果你有 npm 安装错误，在继续之前你必须解决并修复这些错误\n 运行项目\n使用如下命令运行项目:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657$ gulp marbles_local  ................#这里省略了许多输出信息..........  ......----------------------------------- Server Up - localhost:3001 -----------------------------------Welcome aboard: United MarblesChannel: mychannelOrg:  Org1MSPCA: fabric-caOrderer:  fabric-ordererPeer: fabric-peer-org1Chaincode ID: marblesChaincode Version:  v4------------------------------------------ Websocket Up ------------------------------------------info: [fcw] Going to enroll peer_urls=[grpc://localhost:7051], channel_id=mychannel, uuid=marblesDockerComposeNetworkmychannelOrg1MSPfabricpeerorg1, ca_url=http://localhost:7054, orderer_url=grpc://localhost:7050, enroll_id=admin, enroll_secret=adminpw, msp_id=Org1MSP, kvs_path=/home/ubuntu/.hfc-key-storeinfo: [fcw] Successfully loaded enrollment from persistencedebug: added peer grpc://localhost:7051debug: [fcw] Successfully got enrollment marblesDockerComposeNetworkmychannelOrg1MSPfabricpeerorg1info: Success enrolling admindebug: Checking if chaincode is already instantiated or not 1info: Checking for chaincode...debug: [fcw] Querying Chaincode: read()debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[selftest], txId=nulldebug: [fcw] Peer Query Response - len: 5 type: numberdebug: [fcw] Successful query transaction.----------------------------- Chaincode found on channel \"mychannel\" -----------------------------info: Checking chaincode and ui compatibility...debug: [fcw] Querying Chaincode: read()debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[marbles_ui], txId=nullwarn: [fcw] warning - query resp is not json, might be okay: string 4.0.1debug: [fcw] Successful query transaction.info: Chaincode version is goodinfo: Checking ledger for marble owners listed in the config fileinfo: Fetching EVERYTHING...debug: [fcw] Querying Chaincode: read_everything()debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read_everything, args=[], txId=nulldebug: [fcw] Peer Query Response - len: 30 type: objectdebug: [fcw] Successful query transaction.debug: This company has not registered marble ownersinfo: We need to make marble owners- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -info: Detected that we have NOT launched successfully yetdebug: Open your browser to http://localhost:3001 and login as \"admin\" to initiate startup- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n出现上述输出信息,则表示项目启动成功,现在你可以在浏览器中输入 http://localhost:3001来访问本项目,并且您不需要输入密码或更改预先填写的用户名admin.\n注意: 本人在使用gulp marbles_local命令启动项目的过程中出现了如下图的错误,有可能你在运行时也会出现这个错误:\n\n查看 [Issues:208] (https://github.com/IBM-Blockchain/marbles/issues/208) 可以发现有人已经遇到过这种问题, 阅读后发现这个bug是由fabric-sdk-node https://jira.hyperledger.org/browse/FAB-2593 引起的， 需要将hfc-key-store目录复制到您的主目录$HOME / .hfc-key-store，然后重新配置connection_profile_local.json的client.credentialStore.path. 如果你也遇到了这个问题,可以参考如下步骤.\n\n先将hfc-key-store目录复制到您的主目录$HOME / .hfc-key-store:\n\n12cd ~/fabric-samples/fabcarcp -r hfc-key-store  ~/.hfc-key-store\n\n重新配置connection_profile_local.json的client.credentialStore.path:\n\n12cd ~/marbles/configvim connection_profile_local.json\n在文件中定位到下面的片段:\n123456\"client\": &#123;        \"organization\": \"Org1MSP\",        \"credentialStore\": &#123;            \"path\": \"/$HOME/.hfc-key-store\"        &#125;     &#125;,\n将path改为上面的路径(/$HOME/.hfc-key-store)即可.\n\n返回 Marbles 主目录,重新运行本项目\n\n12cd ~/marblesgulp marbles_local\n如果这样,还不能运行,你可以在 issues 里找找看有没有相同的错误, 如果有解答过程,可以按照解答的过程,自己试着解决这些问题.\n 运行配置截图\n\n开始\n\n\n点击选择右边的按钮Guided, 通过这种方式即可以了解 Fabric 又能自定义一些设置\n\n第一步：检查连接配置数据\n\n\n第一步是检查你的连接配置JSON文件。 检查的文件是：marbles/config/marbles_local.json和``marbles/config/connection_profile_local.json`\n\n第二步：注册管理员\n\n\n接下来，我们尝试将您注册为贵公司的管理员。此步骤与您的证书颁发机构（CA）联系并从您的连接配置文件中提供了enrollID和enrollSecret\n\n第三步：查找 Chaincode\n\n\n现在我们需要在您的channel(通道)上找到链码。检查或修改您的连接配置文件里配置的链码名为弹珠的通道mychannel。\n\n第四步：创建资产\n\n\n作为一个弹珠贸易公司，您可以携带新的弹珠业主。这些弹珠业主代表您的用户群。\n这一步将创建弹珠用户并且每个用户拥有3个弹珠。\n\n\n进行下一步前,请点击Create进行创建\n\n\n第五步：配置完成,点击Enter进入系统\n\n\n\n进入系统后,你可以按照本教程开头，或者下面的Gif动画演示的那样为一个用户创建弹珠资产,或者将一个弹珠资产转移给另一个用户;也可以删除这个弹珠资产.\n\n在每次点击创建,删除,交易资产时其实都是在进行调用链码操作,而且本项目还有动画进行调用链码的演示:\n\n\n当然,还有更多的功能, 你可以在部署后尽情体验!\n 参考\n\nIBM-Blockchain/marbles(官方项目地址)\nnode 版本管理工具 n 无效的原理及解决方案\nUbuntu环境下安装nodejs和npm\nnpm版本怎么降级\nissues:208\n\n","plink":"https://dmego.me/2018/05/15/deploy-IBM-blockchain-marbles/"},{"title":"基于ubuntu16.04快速构建Hyperledger Fabric网络","date":"2018-05-14T23:56:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.541Z","content":"\n\n\n\n 前言\n最近在参加一个比赛,使用到了区块链的开源软件hyperledger,由于之前从未接触过区块链,以及和区块链开发相关的内容,所有在网上查阅了大量的资料,并且通过学习yeasy(杨宝华)开源的入门书籍区块链技术指南以及进阶学习的《区块链原理、设计与应用》,对区块链的一些相关概念有了一定认识。这里记录的是我安装hyperledger fabric的所有步骤，同时也是一个快速搭建单机环境的参考教程。\n 准备好机器环境\n本人的区块链网络部署在VMware搭建的ubuntu16.04的环境下（推荐使用该版本的系统），详细的系统版本为ubuntu-16.04.4-desktop-amd64.iso,是从网易开源镜像站下载的。对于如何使用VMware安装虚拟机以及让虚拟机访问网络，网上有许多教程，这里就不重复讲了。\n当将系统安装完成后，需要更换源，使用desktop版的可以直接在设置里面选择最佳服务器,如下图所示\n\n若使用的是服务器版本,则可以使用如下命令换成高速的源\n\n先备份原来的源文件\n\n1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\n\n打开sources.list文件,删除原来的内容\n\n1sudo vim /etc/apt/sources.list\n\n任选下面一组源文件复制到sources.list中\n\n\n网易源\n\n12345678910deb http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse  deb http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse  deb http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse  deb http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse  deb http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse  deb-src http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse  deb-src http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse  deb-src http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse  deb-src http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse  deb-src http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse\n\n阿里源\n\n123456789101112131415161718# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted  deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties  deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted  deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties  deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted  deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties  deb http://mirrors.aliyun.com/ubuntu/ xenial universe  deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe  deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse  deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse  deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse  deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties  deb http://archive.canonical.com/ubuntu xenial partner  deb-src http://archive.canonical.com/ubuntu xenial partner  deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted  deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties  deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe  deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse\n\n搜狐源\n\n12345678910deb http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse  deb http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse  deb http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse  deb http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse  deb http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse  deb-src http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse  deb-src http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse  deb-src http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse  deb-src http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse  deb-src http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse\n复制进去后,使用:wq保存,然后使用如下命令更新一下\n1sudo apt-get install update\n执行完成后环境就基本上准备好了,如果使用的是服务器版本,觉得使用不方便的话,可以使用xshell之类的远程连接工具连接你的虚拟机。如果你的环境搭建再云服务器上，例如阿里云或者腾讯云，可以不用更新源，直接在自己的主机上使用远程连接工具连接上云主机，环境就算完成了（若在本地不能连接上云主机，或者虚拟机，检查一下ssh是否已经安装并启动,若没有，可以参加网上的教程，配置远程连接）。\n 安装GO语言环境\n不推荐使用apt的方式安装GO,原因是这样安装的版本比较老，推荐安装最新版的GO,具体安装命令如下\n\n下载最新的GO安装包，具体的最新版本号可以从Golang官网上查看\n\n1wegt https://dl.google.com/go/go1.10.2.linux-amd64.tar.gz\n\n解压安装包到/usr/local目录下\n\n1sudo tar -C /usr/local -xzf go1.10.2.linux-amd64.tar.gz\n\n编辑当前用户的环境变量\n\n1vim ~/.profile\n添加如下内容\n12345export PATH=$PATH:/usr/local/go/binexport GOROOT=/usr/local/go#这里配置的GOPATH目录为家目录的的go文件夹export GOPATH=$HOME/goexport PATH=\nPATH:\n\n\n\n\n\n\n\n\n \n \n \n \n \n\nHOME/go/bin\n使用:wq保存后使用如下命令将保存立即刷新\n1source ~/.profile\n\n建立GOPATH目录\n由于在环境变量中配置了GOPATH目录的位置，所以我们需要在家目录下创建该文件夹\n\n12cd ~mkdir go\n\n查看go版本，测试环境配置是否成功\n\n12$ go versiongo version go1.10 linux/amd64\n 安装Docker\n这里使用的Docker的官方文档来安装docker\n\n如果系统中有旧版本的Docker,需要先使用如下命令卸载\n\n1$ sudo apt-get remove docker docker-engine docker.io\n\n更新apt包索引\n\n1sudo apt-get update\n\n安装软件包以允许apt通过HTTPS使用远程库\n\n12345sudo apt-get install \\    apt-transport-https \\    ca-certificates \\    curl \\    software-properties-common\n若出现无法识别命令，可以先将该命令复制到一个文本文件中，将\\去掉，将所有语句放在同一行下，然后复制执行。\n\n添加Docker的官方GPG密钥\n\n1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n\n通过搜索指纹的最后8个字符，确认您现在拥有指纹识别码9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88\n\n123456$ sudo apt-key fingerprint 0EBFCD88pub   4096R/0EBFCD88 2017-02-22      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;sub   4096R/F273FCD8 2017-02-22\n\n使用以下命令设置稳定版本的远程库\n\n1234$ sudo add-apt-repository \\   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\   $(lsb_release -cs) \\   stable\"\n\n再次更新apt包索引\n\n1sudo apt-get update\n\n使用apt安装docker-ce\n\n1sudo apt-get install docker-ce\n\n查看docker版本，测试环境配置是否成功\n\n1234567891011121314151617181920$ docker versionClient: Version:      18.03.1-ce API version:  1.37 Go version:   go1.9.5 Git commit:   9ee9f40 Built:        Thu Apr 26 07:17:20 2018 OS/Arch:      linux/amd64 Experimental: false Orchestrator: swarmServer: Engine:  Version:      18.03.1-ce  API version:  1.37 (minimum version 1.12)  Go version:   go1.9.5  Git commit:   9ee9f40  Built:        Thu Apr 26 07:15:30 2018  OS/Arch:      linux/amd64  Experimental: false\n安装完成之后，需要将当前用户添加到docker用户组，然后为该用户添加sudo权限\n\n若没有创建docker用户组，可以使用如下命令创建一个GID为999，组名为docker的用户组\n\n1sudo groupadd –g 999 docker\n\n将当前用户(ubuntu)添加到docker用户组并分配sudo权限\n\n1sudo usermod -aG docker ubuntu\n注销后重新登录，然后添加阿里云的Docker Hub镜像（注意，不同版本的添加方法不同，见阿里云容器 Hub）\n12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123;    \"registry-mirrors\": [\"https://obou6wyb.mirror.aliyuncs.com\"]&#125;EOF$ sudo systemctl daemon-reload$ sudo systemctl restart docker\n如果觉得阿里云镜像不好用，可以选择DaoClound的镜像,配置方式见DaoCloud官方文档\n 安装Docker-Compose\nDocker-Compose是支持通过模板脚本批量创建的一个组件。在安装 Docker-Compose之前，需要安装python-pip\n\n安装python-pip\n\n1sudo apt-get python-pip\n\n\n下载 Docker-Compose，这里使用的是国内的DaoClound加速器进行下载12curl -L https://get.daocloud.io/docker/compose/releases/download/1.12.0/docker-compose-`uname -s`-`uname -m` &gt; ~/docker-compose\n\n\n将Docker-Compose文件夹移动到/usr/local/bin目录下\n\n\n​1sudo mv ~/docker-compose /usr/local/bin/docker-compose\n\n为Docker-Compose附上可执行权限\n\n12chmod +x /usr/local/bin/docker-compose\n 下载Fabric源码\n\n先在GOPATH下创建对应的目录\n\n1$ mkdir -p ~/go/src/github.com/hyperledger\n\n切换到对应目录，使用Git命令将fabric的源码从github上克隆下来\n\n1cd ~/go/src/github.com/hyperledgergit clone https://github.com/hyperledger/fabric.git\n\n由于Fabric一直在更新，而我们并不需要使用最新的源码，所有将版本切换到v1.0.0\n\n12$ cd ~/go/src/github.com/hyperledger/fabricgit checkout v1.0.0\n 下载Fabric Docker镜像\n由于刚才设置了Docker Hub镜像的地址，并且官方文件中也提供了批量下载的脚本，所有我们只需运行下面命令即可\n12$ cd ~/go/src/github.com/hyperledger/fabric/examples/e2e_cli/$ source download-dockerimages.sh -c x86_64-1.0.0 -f x86_64-1.0.0\n由于刚才设置的是国内的镜像站，在本地网速还不错的情况下下载数度还是很快的。当下载完成后，使用如下命令检查镜像列表\n1234567891011121314151617181920212223docker imagesREPOSITORY                              TAG                 IMAGE ID            CREATED             SIZEdev-peer0.org1.example.com-marbles-v4   latest              089d43e100c9        5 hours ago         173MBdev-peer0.org1.example.com-fabcar-1.0   latest              6047921ee993        7 hours ago         173MBhyperledger/fabric-tools                latest              0403fd1c72c7        10 months ago       1.32GBhyperledger/fabric-tools                x86_64-1.0.0        0403fd1c72c7        10 months ago       1.32GBhyperledger/fabric-couchdb              latest              2fbdbf3ab945        10 months ago       1.48GBhyperledger/fabric-couchdb              x86_64-1.0.0        2fbdbf3ab945        10 months ago       1.48GBhyperledger/fabric-kafka                latest              dbd3f94de4b5        10 months ago       1.3GBhyperledger/fabric-kafka                x86_64-1.0.0        dbd3f94de4b5        10 months ago       1.3GBhyperledger/fabric-zookeeper            latest              e545dbf1c6af        10 months ago       1.31GBhyperledger/fabric-zookeeper            x86_64-1.0.0        e545dbf1c6af        10 months ago       1.31GBhyperledger/fabric-orderer              latest              e317ca5638ba        10 months ago       179MBhyperledger/fabric-orderer              x86_64-1.0.0        e317ca5638ba        10 months ago       179MBhyperledger/fabric-peer                 latest              6830dcd7b9b5        10 months ago       182MBhyperledger/fabric-peer                 x86_64-1.0.0        6830dcd7b9b5        10 months ago       182MBhyperledger/fabric-javaenv              latest              8948126f0935        10 months ago       1.42GBhyperledger/fabric-javaenv              x86_64-1.0.0        8948126f0935        10 months ago       1.42GBhyperledger/fabric-ccenv                latest              7182c260a5ca        10 months ago       1.29GBhyperledger/fabric-ccenv                x86_64-1.0.0        7182c260a5ca        10 months ago       1.29GBhyperledger/fabric-ca                   latest              a15c59ecda5b        10 months ago       238MBhyperledger/fabric-ca                   x86_64-1.0.0        a15c59ecda5b        10 months ago       238MBhyperledger/fabric-baseos               x86_64-0.3.1        4b0cab202084        12 months ago       157MB\n出现以上结果说明镜像已经下载成功\n 启动Fabric网络并运行e2e_cli项目\n\n进入e2e_cli目录，并执行启动命令\n\n12$ cd ~/go/src/github.com/hyperledger/fabric/examples/e2e_cli/$ ./network_setup.sh up\n这个过程做了如下操作\n\n1.编译生成Fabric公私钥，证书的程序，程序在目录：fabric/release/linux-amd64/bin下\n\n\n2.基于configtx.yaml生成创世区块和通道相关信息，并保存到channel-artifacts文件夹中\n\n\n3.基于crypto-config.yaml生成公私钥和证书信息，并保存在crypto-config文件夹中\n\n\n4.基于docker-compose-cli.yaml启动1 Orderer + 4 Peer + 1 CLI的Fabric容器\n\n\n5.在CLI启动的时候，会运行srcipt/script.sh文件，这个脚本文件包含了创建Channel,加入Channel，安装Example02,运行Example02等功能\n\n最后运行完成，我们会看到如下截图，说明网络启动成功了\n\n 手动测试一下Fabric网络\n我们以安装好的Example02进行测试,在官方例子中，channel的名字是mychannel,链码的名字是mycc,我们首先重新打开一个命令行，然后进入CLI，\n\n输入以下命令即可\n\n1$ docker exec -it cli bash\n\n运行以下命令可以查询a账户的余额\n\n1$ peer chaincode query -C mychannel -n mycc -c '&#123;\"Args\":[\"query\",\"a\"]&#125;'\n查询结果如下图所示\n\n可以看到a账户的余额现在是90\n\n运行以下命令可以查询b账户的余额\n\n1$ peer chaincode query -C mychannel -n mycc -c '&#123;\"Args\":[\"query\",\"b\"]&#125;'\n查询结果如下图所示\n\n可以看到b账户的余额现在是210\n\n现在将b账户的余额转100给a账户，运行如下命令\n\n1peer chaincode invoke -o orderer.example.com:7050  --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C mychannel -n mycc -c '&#123;\"Args\":[\"invoke\",\"b\",\"a\",\"100\"]&#125;'\n执行结果如下图所示\n\n可以看到执行成功了\n\n再次查询a账户的余额\n\n1$ peer chaincode query -C mychannel -n mycc -c '&#123;\"Args\":[\"query\",\"a\"]&#125;'\n查询结果如下图所示\n\n可以看到a账户的余额现在是190,比之前多了100\n\n再次查询b账户的余额\n\n1$ peer chaincode query -C mychannel -n mycc -c '&#123;\"Args\":[\"query\",\"b\"]&#125;'\n查询结果如下图所示\n\n可以看到b账户的余额现在是110,比之前少了100\n调用链码一切正常\n 关闭区块链网络\n\n退出CLI容器\n\n1root@4941e8bd4bd6:/opt/gopath/src/github.com/hyperledger/fabric/peer# exit\n\n关闭Fabric网络\n\n12$ cd ~/go/src/github.com/hyperledger/fabric/examples/e2e_cli$ ./network_setup.sh down\n最后出现如下图说明关闭区块链网络成功\n\n 总结\n至此，部署以及测试fabric的环境已经全部完成，下一篇博客我将记录如何在此基础上部署及运行IBM官方区块链例子marbles(弹珠资产)\n 参考\n\n快速搭建一个Fabric 1.0的环境\nHyperledger Fabric 1.0 从零开始（五）——运行测试e2e\n超级账本搭建流程fabric-sample first-network\n\n","plink":"https://dmego.me/2018/05/14/quick-start-hyperledger-fabric/"},{"title":"fastJosn使用总结","date":"2018-05-13T19:56:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.545Z","content":"\n\n\n\n 前言\n最近在开发过程中使用了大量的json作为前后端数据交换的方式,由于之前没有对json做过系统的学习,所有在使用过程中查阅了大量的文档与资料,这里主要记录了我在开发后对json以及fastjson使用的总结\n JSON 介绍\nJSON(javaScript Object Notation)是一种轻量级的数据交换格式。主要采用键值对({&quot;name&quot;: &quot;json&quot;})的方式来保存和表示数据。JSON是JS对象的字符串表示法，它使用文本表示一个JS对象的信息，本质上是一个字符串。更多简介见介绍JSON。\n fastjson 简介\n在日志解析,前后端数据传输交互中,经常会遇到字符串(String)与json,XML等格式相互转换与解析，其中json以跨语言，跨前后端的优点在开发中被频繁使用，基本上可以说是标准的数据交换格式。fastjson是一个java语言编写的高性能且功能完善的JSON库，它采用一种“假定有序快速匹配”的算法，把JSON Parse 的性能提升到了极致。它的接口简单易用，已经被广泛使用在缓存序列化，协议交互，Web输出等各种应用场景中。\n fastjson 常用 API\nfastjson API 入口类是com.alibaba.fastjson.JSON,常用的序列化操作都可以在JSON类上的静态方法直接完成。\n12345678public static final Object parse(String text); // 把JSON文本parse为JSONObject或者JSONArray public static final JSONObject parseObject(String text)； // 把JSON文本parse成JSONObject    public static final &lt;T&gt; T parseObject(String text, Class&lt;T&gt; clazz); // 把JSON文本parse为JavaBean public static final JSONArray parseArray(String text); // 把JSON文本parse成JSONArray public static final &lt;T&gt; List&lt;T&gt; parseArray(String text, Class&lt;T&gt; clazz); //把JSON文本parse成JavaBean集合 public static final String toJSONString(Object object); // 将JavaBean序列化为JSON文本 public static final String toJSONString(Object object, boolean prettyFormat); // 将JavaBean序列化为带格式的JSON文本 public static final Object toJSON(Object javaObject); //将JavaBean转换为JSONObject或者JSONArray。\n 使用方法举例\n123//将JSON文本转换为java对象import com.alibaba.fastjson.JSON;Model model = JSON.parseObject(jsonStr, Model.class);\n 有关类库的一些说明\n\nJSONArray : 相当于 List&lt;Object&gt;\nJSONObject: 相当于 Map&lt;String,Object&gt;\n\n fastjson 使用实例\n java对象与JSON字符串的互转\nUser测试类\n1234567891011121314151617181920212223242526272829/** * User测试类 * @author dmego */public class User &#123;\tprivate String username;\tprivate String password;\tpublic User()&#123;&#125;\tpublic User(String username,String password)&#123;\t\tthis.username = username;\t\tthis.password = password;\t&#125;\tpublic String getUsername() &#123;\t\treturn username;\t&#125;\tpublic void setUsername(String username) &#123;\t\tthis.username = username;\t&#125;\tpublic String getPassword() &#123;\t\treturn password;\t&#125;\tpublic void setPassword(String password) &#123;\t\tthis.password = password;\t&#125;    @Override\tpublic String toString() &#123;\t\treturn \"User [username=\" + username + \", password=\" + password + \"]\";\t&#125;&#125;\nUserGroup测试类\n123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.List;/** * 用户组测试类 * @author dmego * */public class UserGroup &#123;\tprivate String name;      private List&lt;User&gt; users = new ArrayList&lt;User&gt;();    public UserGroup()&#123;&#125;    public UserGroup(String name,List&lt;User&gt; users)&#123;    \tthis.name = name;    \tthis.users = users;    &#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\tpublic List&lt;User&gt; getUsers() &#123;\t\treturn users;\t&#125;\tpublic void setUsers(List&lt;User&gt; users) &#123;\t\tthis.users = users;\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn \"UserGroup [name=\" + name + \", users=\" + users + \"]\";\t&#125;  &#125;\nfastJson测试类\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package demo;import java.util.ArrayList;import java.util.List;import org.junit.Test;import com.alibaba.fastjson.JSON;/** * fastJson测试类 * @author dmego * */public class TestFastJosn &#123;\t/**\t * java对象转 json字符串 \t */\t@Test\tpublic void objectTOJson()&#123;\t\t//简单java类转json字符串\t\tUser user = new User(\"dmego\", \"123456\");\t\tString UserJson = JSON.toJSONString(user);\t\tSystem.out.println(\"简单java类转json字符串:\"+UserJson);\t\t\t\t//List&lt;Object&gt;转json字符串\t\tUser user1 = new User(\"zhangsan\", \"123123\");\t\tUser user2 = new User(\"lisi\", \"321321\");\t\tList&lt;User&gt; users = new ArrayList&lt;User&gt;();\t\tusers.add(user1);\t\tusers.add(user2);\t\tString ListUserJson = JSON.toJSONString(users);\t\tSystem.out.println(\"List&lt;Object&gt;转json字符串:\"+ListUserJson);\t\t\t\t\t//复杂java类转json字符串\t\tUserGroup userGroup = new UserGroup(\"userGroup\", users);\t\tString userGroupJson = JSON.toJSONString(userGroup);\t\tSystem.out.println(\"复杂java类转json字符串:\"+userGroupJson);\t\t\t\t\t&#125;\t\t/**\t * json字符串转java对象\t * 注：字符串中使用双引号需要转义 (\" --&gt; \\\"),这里使用的是单引号\t */\t@Test\tpublic void JsonTOObject()&#123;\t\t/* json字符串转简单java对象\t     * 字符串：&#123;\"password\":\"123456\",\"username\":\"dmego\"&#125;*/\t\t\t\tString jsonStr1 = \"&#123;'password':'123456','username':'dmego'&#125;\";\t\tUser user = JSON.parseObject(jsonStr1, User.class);\t\tSystem.out.println(\"json字符串转简单java对象:\"+user.toString());\t\t\t\t/*\t\t * json字符串转List&lt;Object&gt;对象\t\t * 字符串：[&#123;\"password\":\"123123\",\"username\":\"zhangsan\"&#125;,&#123;\"password\":\"321321\",\"username\":\"lisi\"&#125;]\t\t */\t\tString jsonStr2 = \"[&#123;'password':'123123','username':'zhangsan'&#125;,&#123;'password':'321321','username':'lisi'&#125;]\";\t\tList&lt;User&gt; users = JSON.parseArray(jsonStr2, User.class);\t\tSystem.out.println(\"json字符串转List&lt;Object&gt;对象:\"+users.toString());\t\t\t\t\t/*json字符串转复杂java对象\t\t * 字符串：&#123;\"name\":\"userGroup\",\"users\":[&#123;\"password\":\"123123\",\"username\":\"zhangsan\"&#125;,&#123;\"password\":\"321321\",\"username\":\"lisi\"&#125;]&#125;\t\t * */\t\tString jsonStr3 = \"&#123;'name':'userGroup','users':[&#123;'password':'123123','username':'zhangsan'&#125;,&#123;'password':'321321','username':'lisi'&#125;]&#125;\";\t\tUserGroup userGroup = JSON.parseObject(jsonStr3, UserGroup.class);\t\tSystem.out.println(\"json字符串转复杂java对象:\"+userGroup);\t\t&#125;&#125;\n输出结果\n1234567简单java类转json字符串:&#123;\"password\":\"123456\",\"username\":\"dmego\"&#125;List&lt;Object&gt;转json字符串:[&#123;\"password\":\"123123\",\"username\":\"zhangsan\"&#125;,&#123;\"password\":\"321321\",\"username\":\"lisi\"&#125;]复杂java类转json字符串:&#123;\"name\":\"userGroup\",\"users\":[&#123;\"password\":\"123123\",\"username\":\"zhangsan\"&#125;,&#123;\"password\":\"321321\",\"username\":\"lisi\"&#125;]&#125;json字符串转简单java对象:User [username=dmego, password=123456]json字符串转List&lt;Object&gt;对象:[User [username=zhangsan, password=123123], User [username=lisi, password=321321]]json字符串转复杂java对象:UserGroup [name=userGroup, users=[User [username=zhangsan, password=123123], User [username=lisi, password=321321]]]\n fastjson 解析复杂嵌套json字符串\n这个实例是我在开发中用到的，先给出要解析的json字符串\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[    &#123;        \"id\": \"user_list\",        \"key\": \"id\",        \"tableName\": \"用户列表\",        \"className\": \"cn.dmego.domain.User\",        \"column\": [            &#123;                \"key\": \"rowIndex\",                \"header\": \"序号\",                \"width\": \"50\",                \"allowSort\": \"false\"            &#125;,            &#123;                \"key\": \"id\",                \"header\": \"id\",                \"hidden\": \"true\"            &#125;,            &#123;                \"key\": \"name\",                \"header\": \"姓名\",                \"width\": \"100\",                \"allowSort\": \"true\"            &#125;        ]    &#125;,    &#123;        \"id\": \"role_list\",        \"key\": \"id\",        \"tableName\": \"角色列表\",        \"className\": \"cn.dmego.domain.Role\",        \"column\": [            &#123;                \"key\": \"rowIndex\",                \"header\": \"序号\",                \"width\": \"50\",                \"allowSort\": \"false\"            &#125;,            &#123;                \"key\": \"id\",                \"header\": \"id\",                \"hidden\": \"true\"            &#125;,            &#123;                \"key\": \"name\",                \"header\": \"名称\",                \"width\": \"100\",                \"allowSort\": \"true\"            &#125;        ]    &#125;]\n要想解析这种复杂的字符串，首先得先定义好与之相符的java POJO 对象，经过观察，我们发现，这个是一个json对象数组，每一个对象里包含了许多属性，其中还有一个属性的类型也是对象数组。所有，我们从里到外，先定义最里面的对象：\n123456789101112131415public class Column &#123;\tprivate String key;\tprivate String header;\tprivate String width;\tprivate String allowSort;\tprivate String hidden;\t\tpublic String getKey() &#123;\t\treturn key;\t&#125;\tpublic void setKey(String key) &#123;\t\tthis.key = key;\t&#125;    //这里省略部分getter与setter方法\t&#125;\n再定义外层的对象：\n12345678910111213141516171819202122232425262728293031import java.util.List;import org.apache.commons.collections4.map.LinkedMap;public class Query &#123;\tprivate String id;\tprivate String key;\tprivate String tableName;\tprivate String className;    private List&lt;LinkedMap&lt;String, Object&gt;&gt; column;     private List&lt;Column&gt; columnList;    \tpublic String getId() &#123;\t\treturn id;\t&#125;\tpublic void setId(String id) &#123;\t\tthis.id = id;\t&#125;    //这里省略部分getter与setter方法\t\tpublic List&lt;LinkedMap&lt;String, Object&gt;&gt; getColumn() &#123;\t\treturn column;\t&#125;\tpublic void setColumn(List&lt;LinkedMap&lt;String, Object&gt;&gt; column) &#123;\t\tthis.column = column;\t&#125;\tpublic List&lt;Column&gt; getColumnList() &#123;\t\treturn columnList;\t&#125;\tpublic void setColumnList(List&lt;Column&gt; columnList) &#123;\t\tthis.columnList = columnList;\t&#125;&#125;\n我的这个json文件放置在类路径下，最后想将这个json字符串转化为List对象，并且将column 对象数组转化为query对象里的List属性\n而实际转化过程中，fastjson将column对象数组转化为List;所有我们还需要将Map类型转化为object类型才能满足需求。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061   /** * 读取类路径下的配置文件 * 解析成对象数组并返回 * @throws IOException */@Testpublic List&lt;Query&gt; test() throws IOException &#123;\t// 读取类路径下的query.json文件\tClassLoader cl = this.getClass().getClassLoader();\tInputStream inputStream = cl.getResourceAsStream(\"query.json\");\tString jsontext = IOUtils.toString(inputStream, \"utf8\");\t// 先将字符jie串转为List数组\tList&lt;Query&gt; queryList = JSON.parseArray(jsontext, Query.class);\tfor (Query query : queryList) &#123;\t\tList&lt;Column&gt; columnList = new ArrayList&lt;Column&gt;();\t\tList&lt;LinkedMap&lt;String,Object&gt;&gt; columns = query.getColumn();\t\tfor (LinkedMap&lt;String, Object&gt; linkedMap : columns) &#123;\t\t\t//将map转化为java实体类\t\t\tColumn column = (Column)map2Object(linkedMap, Column.class);\t\t\tSystem.out.println(column.toString());\t\t\tcolumnList.add(column);\t\t&#125;\t\tquery.setColumnList(columnList); //为columnList属性赋值\t&#125;       return queryList;&#125;   /**    * Map转成实体对象    * @param map map实体对象包含属性    * @param clazz 实体对象类型    * @return    */   public static Object map2Object(Map&lt;String, Object&gt; map, Class&lt;?&gt; clazz) &#123;       if (map == null) &#123;           return null;       &#125;       Object obj = null;       try &#123;           obj = clazz.newInstance();           Field[] fields = obj.getClass().getDeclaredFields();           for (Field field : fields) &#123;               int mod = field.getModifiers();               if (Modifier.isStatic(mod) || Modifier.isFinal(mod)) &#123;                   continue;               &#125;               field.setAccessible(true);               String flag = (String) map.get(field.getName());               if(flag != null)&#123;               \tif(flag.equals(\"false\") || flag.equals(\"true\"))&#123;                   \tfield.set(obj, Boolean.parseBoolean(flag));                   &#125;else&#123;                   \tfield.set(obj, map.get(field.getName()));                   &#125;               &#125;                           &#125;       &#125; catch (Exception e) &#123;           e.printStackTrace();       &#125;        return obj;   &#125;\n 参考\n\nfastJson\nJSON最佳实践\n介绍 JSON\nW3Cschool FastJson 教程\n\n","plink":"https://dmego.me/2018/05/13/using-fastjson/"},{"title":"微信小程序：出发吧一起","date":"2017-12-04T13:45:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.545Z","content":"\n\n\n\n 前言\n经过将近一个多月的开发,我们团队开发的微信小程序 “出发吧一起” 终于开发完成,现在的线上版本为 2.2.4-beta 版\n本文档主要介绍该小程序在开发中所用到的技术,已经在开发中遇到问题的采取的解决方法\n\n\n原文链接（转载请注明出处）：微信小程序：出发吧一起\n\n\n开源地址\n\n\n 小程序简介\n“让兴趣不再孤单，让爱好不再流浪” 是微信小程序《出发吧一起》的主题，这款小程序旨在解决当代大学生在校园生活中的孤独感，让大家找到志同道合的朋友，在跑步、健身、竞赛等活动中找到伙伴。利用小程序即开即用，用完就走的特点与交友相结合，它将会是一款高效快捷、无负担的线下交友利器\n本小程序由 bmob 后端云提供数据处理与存储支持\n 小程序码\n\n欢迎扫描体验\n\n\n\n\n 开发中技术问题汇总\n 1.使用e.target.dataset的出现问题\n在小程序开发过程中,我们经常会用到标签中属性的属性值,我们通常会在 &lt;view&gt; 中 设置 data-*=&quot;&quot; 然后在 JS 里通过 e.target.dateset.* 来获取XXX值,但是我经常遇到获取的是undefined,使用 console.log(e) 查看输出信息会发现,在 e对象中包含两个对象分别是currentTarget和target,而往往有些时候数据在currentTarget中,\n此时可以将代码替换成这样来获取值\n\nWXML\n\n1&lt;view bindtap=\"bintap\" data-id=\"1\"&gt;&lt;/view&gt;\n\nJS\n\n123bintap:function(e)&#123;    var id = e.currentTarget.dataset.id;&#125;\n网上还有一直说法是 data-* 里 * 命名的问题,去掉驼峰式命名,纯小写也能解决\n 2.小程序 textarea 文本框如何显示实时字数\n\nWXML\n\n123456&lt;view&gt;    &lt;view&gt;        &lt;textarea name=\"content\" bindinput=\"bindTextAreaChange\" maxlength=\"&#123;&#123;noteMaxLen&#125;&#125;\" /&gt;        &lt;view class=\"chnumber\"&gt;&#123;&#123;noteNowLen&#125;&#125;/&#123;&#123;noteMaxLen&#125;&#125;&lt;/view&gt;    &lt;/view&gt;&lt;/view&gt;\n\nJS\n\n12345678910111213141516data:&#123;    noteMaxLen: 200,//备注最多字数    noteNowLen: 0,//备注当前字数&#125;  //字数改变触发事件  bindTextAreaChange: function (e) &#123;    var that = this    var value = e.detail.value,      len = parseInt(value.length);    if (len &gt; that.data.noteMaxLen)      return;    that.setData(&#123;      content: value, noteNowLen: len    &#125;)  &#125;,\n 3.利用 JS 实现模糊查询\n由于我们使用的是 Bmob 后端云提供的数据处理与存储支持，根据 Bmob 提供的开发文档，免费版的应用无法进行模糊查询，看到这里，再看看已经快完工的活动检索界面，感受无法言说。正当准备放弃的时候，突然想到一个方法，那就是先把所有的后台所有数据都存到集合里，然后根据输入的检索值一个个匹配，想到之后马上就开始着手干了，先查了一下javaScript 文档,String 对象有一个方法是 indexOf() ,可返回某个指定的字符串值在字符串中首次出现的位置,这样就成了,遍历 所以数据,检索每一条数据的每个字符,如果出现了则将它加入到检索结果的集合中.\n\nJS\n\n12345678910111213141516171819202122232425//js 实现模糊匹配查询  findEach: function (e) &#123;    var that = this    var strFind = that.data.wxSearchData.value; //这里使用的 wxSearch 搜索UI插件,    if (strFind == null || strFind == \"\") &#123;      wx.showToast(&#123;        title: '输入为空',        icon: 'loading',      &#125;)    &#125;    if (strFind != \"\") &#123;      var nPos;      var resultPost = [];      for (var i in smoodList) &#123;        var sTxt = smoodList[i].title || ''; //活动的标题        nPos = sTxt.indexOf(strFind);         if (nPos &gt;= 0) &#123;//如果输入的关键字在该活动标题中出现过,则匹配该活动          resultPost.push(smoodList[i]); //将该活动加入到搜索到的活动列表中        &#125;      &#125;      that.setData(&#123;        moodList: resultPost      &#125;)    &#125;  &#125;,\n更加详细的代码请前往Github查看\n 4.使用 JS 将字符串格式的时间转换成几秒前,几分钟前…\n由于小程序中涉及评论,加入活动,收藏等一系列包括事件时间的功能,而数据库中存的时间格式为 2017-11-30 23:36:10 现在想要在界面上不显示具体时间,而是显示与当前时间的差,即几秒前,几分钟前等等\n实现起来并不复杂,主要思路是先把字符串的时间转换成时间戳,然后与当前的时间戳进行比较,这样就能转换成几秒前、几分钟前、几小时前、几天前等形式了\n\nJS\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//字符串转换为时间戳function getDateTimeStamp(dateStr) &#123;  return Date.parse(dateStr.replace(/-/gi, \"/\"));&#125;//格式化时间function getDateDiff(dateStr) &#123;  var publishTime = getDateTimeStamp(dateStr) / 1000,    d_seconds,    d_minutes,    d_hours,    d_days,    timeNow = parseInt(new Date().getTime() / 1000),    d,    date = new Date(publishTime * 1000),    Y = date.getFullYear(),    M = date.getMonth() + 1,    D = date.getDate(),    H = date.getHours(),    m = date.getMinutes(),    s = date.getSeconds();  //小于10的在前面补0  if (M &lt; 10) &#123;    M = '0' + M;  &#125;  if (D &lt; 10) &#123;    D = '0' + D;  &#125;  if (H &lt; 10) &#123;    H = '0' + H;  &#125;  if (m &lt; 10) &#123;    m = '0' + m;  &#125;  if (s &lt; 10) &#123;    s = '0' + s;  &#125;  d = timeNow - publishTime;  d_days = parseInt(d / 86400);  d_hours = parseInt(d / 3600);  d_minutes = parseInt(d / 60);  d_seconds = parseInt(d);  if (d_days &gt; 0 &amp;&amp; d_days &lt; 3) &#123;    return d_days + '天前';  &#125; else if (d_days &lt;= 0 &amp;&amp; d_hours &gt; 0) &#123;    return d_hours + '小时前';  &#125; else if (d_hours &lt;= 0 &amp;&amp; d_minutes &gt; 0) &#123;    return d_minutes + '分钟前';  &#125; else if (d_seconds &lt; 60) &#123;    if (d_seconds &lt;= 0) &#123;      return '刚刚';    &#125; else &#123;      return d_seconds + '秒前';    &#125;  &#125; else if (d_days &gt;= 3 &amp;&amp; d_days &lt; 30) &#123;    return M + '-' + D + ' ' + H + ':' + m;  &#125; else if (d_days &gt;= 30) &#123;    return Y + '-' + M + '-' + D + ' ' + H + ':' + m;  &#125;&#125;\n 5.微信小程序提交表单清空表单数据\n在发布活动之后,由于表单中的数据没有清空,给用户的体验必定不好,然而小程序的数据交互并不像html + jS 那样,使用 dataSet({}) 来给赋值,视图层就能通过异步的方式活动到值,于是想到,在提交表单后,给这些input都赋值为空,那样就实现了清空表单的效果,当然,表单中并不只包含input,但是都可以通过这种方式实现清空效果\n\nWXML\n\n12345&lt;form bindsubmit=\"submitForm\"&gt;    &lt;text class=\"key\"&gt;活动名称&lt;/text&gt;    &lt;input name=\"title\"  maxlength=\"100\" value=\"&#123;&#123;title&#125;&#125;\" /&gt;    &lt;button  formType=\"submit\"&gt;确定&lt;/button&gt;&lt;/form&gt;\n\nJS\n\n12345678910submitForm:function(e)&#123;     var title = e.detail.value.title;     ......     success: function (res) &#123;         //将title值设置空        that.setData(&#123;            title: ''         &#125;     &#125;&#125;\n 6.微信号,QQ号,手机号 正则校验\n由于申请加入活动需要填写真实姓名,联系方式等信息,为了防止用户随意填写信息,必须要对这些信息进行校验\n\nJS\n\n1234var wxReg = new RegExp(\"^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$\"); //微信号正则校验var qqReg = new RegExp(\"[1-9][0-9]&#123;4,&#125;\"); //QQ号正则校验var phReg = /^1[34578]\\d&#123;9&#125;$/; //手机号正则校验var nameReg = new RegExp(\"^[\\u4e00-\\u9fa5]&#123;2,4&#125;$\"); //2-4位中文姓名正则校验\n 7.使用 Bmob SDK 实现报名成功发送模板消息,生成小程序二维码等\n在开发过程中,由于想要实现,当用户报名成功后如何通知用户,查阅了小程序的开发文档发现有一个发送模板消息的API,再查询 Bmob 的开发文档,发现实现了这个功能,这个真的太有用了.模板消息只能再真机上才能发送成功,经过配置,重要成功,但是有在使用中出现一个问题\n,就是在小程序发布后 模板消息中如果带有  page 参数将不会发送,但是在开发版中能发送成功, 这个问题已经反馈了,估计等Bmob小程序SDK更新后会解决这个问题.\n具体代码我就不写了,bmob开发文档直达\n\n发送模板消息\n生成小程序二维码\n\n 截图 &amp; GIF\n\n\n\n\n\n Bmob 数据库表结构设计\n 用户表:(_User，自带表)\n|--objectId //Id\n|--userPic(String) //用户头像\n|--username(String) //用户名\n|--password(String) //密码\n|--nickname(String) //昵称\n|--sex(Number) //性别\n|--userData(Object) //微信登录用户数据\n|--eventJoin(Array) //参加的活动Id 数组Array\n|--eventFavo(Array) //收藏的活动Id 数组Array\n|--feednum(Number) //反馈次数\n\n 活动信息表：(Events)\n|--objectId //活动Id\n|--publisher(Pointer--&gt;_User) //发起人\n|--title(String) //活动主题\n|--content(String) //活动内容\n|--actpic(File) //活动宣传照片\n|--acttype(String) //活动类别\n{\n    1：运动,2：游戏,3：交友,\n    4：旅行,5：读书,6：竞赛,\n    7：电影,8: 音乐,9: 其他\n}\n|--isShow(Number) //是否公开显示在首页\n|--endtime(String) //组队截止时间\n|--address(String) //活动地点\n|--latitude(Number)  //地址纬度\n|--longitude(Number) //地址经度\n|--peoplenum(String)//人数限制\n|--likenum(Number)  //点赞数\n|--liker(Array) //点赞人Id集合\n|--commentnum(Number) //评论数\n|--joinnumber(Number) // 现在参加的人数\n|--joinArray(Array) // 现在参加的人集合\n\n 活动信息扩展表:(EventMore)\n|--objectId //活动信息扩展表Id\n|--event(Pointer--&gt;Events) //活动\n|--Status(Number) //活动状态,(1:准备中,2:进行中,3:已结束)\n|--Statusname(String) //活动状态名称\n|--qrcode(File) //活动群聊二维码\n\n 评论表：(Comments)\n|--objectId //评论Id\n|--publisher(Pointer--&gt;_User) //评论发布者\n|--olderUsername(String) //上一条评论人昵称\n|--olderComment(Pointer--&gt;Comments) //上一条评论\n|--event(Pointer--&gt;Events) //评论的活动\n|--content(String)  //评论内容\n\n 点赞表：(Likes)\n|--objectId //点赞的Id\n|--liker(Pointer--&gt;_User) //点赞人\n|--event(Pointer--&gt;Events) //点赞的活动\n\n 收藏表:(Favos)\n|--objectId //收藏的Id\n|--favor(Pointer--&gt;_User)  //收藏者\n|--event(Pointer--&gt;Events) //收藏的活动\n\n 消息通知表:(Plyre)\n|--objectId //消息通知的Id\n|--fid(String)  //活动发布者Id(被赞或者被取消赞的人的ID,或者被回复,被评论的人的ID)(被通知的人)\n|--uid(Pointer--&gt;_User)   //消息通知人\n|--wid (String) //被赞，或者取消赞，被评论，或者被回复，加入，取消加入的活动id\n|--avatar (String) //消息通知人的头像\n|--username (String) //消息通知人的姓名\n|--is_read(Number) //这条消息是否已读（1代表已读，0代表未读）\n|--bigtype(Number) //消息通知大类(1代表消息，2代表通知)\n|--behavior(Number) //(消息提醒类型)\n{\n\t1：赞\n\t2：取消赞\n\t3：被评论\n\t4：被回复\n\t5：加入活动\n\t6：取消加入活动\n\t7：修改了加入信息\n}\n\n 活动联系表:(Contact)\n|--objectId //联系表Id\n|--publisher(Pointer--&gt;_User)  //活动发布者\n|--currentUser (Pointer--&gt;_User) //当前用户\n|--event(Pointer--&gt;Events)  //想要加入的活动\n|--realname (String) //真实姓名\n|--contactWay(String) //联系方式(微信号,手机号,QQ号)\n|--contactValue(String) //联系方式的号码\n\n 反馈表:(Feedback)\n|--objectId //反馈Id\n|--feedUser(Pointer--&gt;_User) //反馈人Id\n|--title(String) //反馈标题\n|--content(String) //反馈内容\n|--feedpic(File) //反馈图片\n|--feedinfo(String) //反馈用户的设备信息 \t\n\n 感谢以下开源项目、网站社区\n\nBmob后端云\n微信小程序联盟\nWeUI for 小程序\n有赞小程序 UI 库\n微信小程序自定义组件（对话框、指示器、五星评分…）\n微信小程序优雅的搜索框\nWe重邮\nQQ 向左滑动删除操作\n模仿QQ6.0侧滑菜单\n守望轩\n\n…\n","plink":"https://dmego.me/2017/12/04/wechat-app-together/"},{"title":"使用Travis CI自动部署Hexo到GitHub","date":"2017-10-13T17:46:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.525Z","content":"\n 前言\n使用 hexo + gitPages 搭建个人博客的人都知道，每当要发表一篇博文，第一步得手动使用 hexo g 命令生成静态网页，然后还得通过 hexo d 命令将静态文件推送到GitHub远程仓库,不说麻烦不麻烦，更重要的是有时候环境换了，没有搭建 hexo 环境，想发篇博客的时候就没有可能了。而现在通过 Travis CI 就能自动构建自己的博客。我们只需将写好的 Markdown 格式的博文push 到 hexo源文件 分支即可。\n Travis CI 介绍\nTravis CI 是目前新兴的开源持续集成构建项目，它与 jenkins，GO的很明显的特别在于采用 yaml 格式，简洁清新独树一帜。目前大多数的 github 项目都已经移入到 Travis CI 的构建队列中，据说 Travis CI 每天运行超过 4000 次完整构建。\n hexo 介绍\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n 使用 Travis 自动构建\n我的博客自动部署思路是，将  hexo 源码 push 到博客 项目的另外一个分支，\n既一个分支放源码，一个分支放静态文件，使用 Travis CI 自动部署 hexo 源码的分支，构建完成后自动推送到 静态文件的分支上，而这一切都在一个仓库上进行操作。\n注意：如果使用的是GitPage的个人站点来搭建博客的 ，则博客静态文件在 master分支上；如果使用的是 gitPages 的项目站点来搭建博客，则博客的静态文件在 gh-pages 分支上。\n 在GitHub 上生成 Access Token\n如果想要 让travis CI 构建完成之后自动 push 到 master 分支，则travis需要有对这个仓库进行操作的权限，此时我们就需要为Travis CI 配置Access Token（访问令牌）。\n在GitHub上生成Access Token 的步骤是，点击头像进入设置（Settings）,r然后点击左边菜单栏最下面的Developer settings 选项，进入后点击左边的 Personal access tokens 选项，进入后点击右上角的Generate new token 按钮\n\n点击后就会来到下面的界面，先给 Token 起一个名字，然后为它设置一些权限，其中红框内的权限是必须的，其他可以随意添加。\n\n点击下面的 create token 按钮，就会生成一个已经赋予好权限的 token 值，接下来我们Travis CI 网站的配置中。\n\n 配置 Travis CI\n如果之前从未使用 Travis CI 来构建项目，则我们先需要使用GitHub账号来登录网站,登录进来后，会进到如下图界面，如果底下 没有把 GitHub 仓库中的项目加载进来，可以手动点击右上角的  Sync account 按钮，待到同步完成后将要自动构建的项目开启。\n\n开启后点击设置图标就可以进行一系列的设置，如下图所示，先开启 General 里的两项选项：\n\nBuild only if .travis.yml is present:只有在.travis.yml文件中配置的分支改变了才构建\nBuild branch updates:当分支更新后开始构建\n\n然后在  Environment Variables 一栏里将在 GitHub 下获取的 Access Token 值添加进来\n\n 添加配置文件到Hexo源码分支下\n上面提到的 .travis.yml 配置文件需要添加到hexo 源码的根目录下，因为Travis CI 在自动构建时需要获取这些配置将信息，以此来完成构建任务；这些配置信息主要包括源码分支，静态文件推送分支，仓库地址等信息。\n\n其中主要内容如下：\n1234567891011121314151617181920212223242526272829language: node_jsnode_js: stable# S: Build Lifecycleinstall:  - npm install#before_script: # - npm install -g gulpscript:  - hexo gafter_script:  - cd ./public  - git init  - git config user.name \"dmego\" --&#123;GitHub账户名称&#125;  - git config user.email \"zengkai12138@outlook.com\" --&#123;Github账户邮箱&#125;  - git add .  - git commit -m \"Update docs\"  - git push --force --quiet \"https://\n{GH_TOKEN}@\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n\n \n \n \n \n \n\n&#123;GH_REF&#125;\" master:master# E: Build LifeCyclebranches:  only:    - hexo --&#123;Hexo源码分支名称&#125;env: global:   - GH_REF: github.com/dmego/dmego.github.io.git --&#123;仓库地址&#125;\n配置到这一步就已经把所有配置全部完成，下面就是验证的过程\n 构建并自动部署结果\n将某篇文章中的一个表格增加一行后将修改推送到hexo源码所在的hexo分支\n,然后等Travis CI 构建并自动部署成功后。\n\n点击博文发现表格多了一行。\n\n 总结\n这样做虽然能很好的实现自动部署的功能，但是有个问题也要注意，就是博客源码公开问题，如果对博客源码不介意的可以直接使用公开仓库，如果介意那就没有办法了，除非使用付费的私有仓库，或者把项目放在Coding上去，因为上有提供免费的私有仓库。就我个人认为，既然是自己的博客，本来就是要给人看的，博客源码也谈不上存在什么隐私。\n","plink":"https://dmego.me/2017/10/13/deylpoy-hexo-with-TravisCI/"},{"title":"Git学习笔记","date":"2017-08-26T10:36:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.529Z","content":"\n 前言\n\n\n本文档笔记是本人通过学习廖雪峰Git教程的整理而来\n\n\n本文档主要记录本人当时在学习过程中认为重要的概念和命令\n\n\n 创建一个版本库\n123mkdir learngit //使用命令创建一个目录cd learngit //进入这个目录pwd //用于显示当前目录\n 初始化仓库\n1git init\n 添加文件到仓库\n12第一步：git add &lt;file&gt;第二步：git commit -m '本次提交的说明'\n12git status:查看当前Git仓库的状态，是否有文件没有提交，让我们掌握仓库最新的状态git diff: 查看不同，当修改文件后，可以查看修改了什么内容（只适用于文本文件）\n\n 实现版本之间回退\n12git log:显示从最近到最远的提交日志git log --pretty=oneline:如果信息太多，使用这行命令\n\n在Git中，用HEAD表示当前版本,上一个版本就是HEAD^，上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n一大串类似882e1e0...67hko896的是commit id 版本号\ngit reset --hard HEAD^: 回退到上一个版本此时，当再次使用git log命令时，发现之前的版本已经消失了，此时想要再次回到那个版本，有两种方式：一种是当命令窗口没有关闭时，找到那个版本的版本号，如：81ac3c5，此时又回到最新的那个版本的命令是：\n\n1git reset --hard 81ac3c5\n如果已经过去很久了，已经记不得想要回退的版本的ID号，此时可以依据这个命令来找回版本号：\n1git reflog\n\n 工作区与暂存区的概念\n\n\n工作区（Working Directory）：就是能在电脑上看到的目录，比如仓库文件夹\n\n\n版本库（Repository）：工作区里有一个隐藏目录.git ，这个不算工作区，而是git的版本库前面我们讲了往Git版本库里添加文件的时候，分两步，这两步更详细的说是：\n\n\n\n第一步使用git add 把文件添加进去，实际上就是把文件修改添加到暂存区；\n第二步使用git commit提交修改，实际上是把暂存区的所有内容提交到当前分支因为我们创建Git版本库的时候，Git自动为我们创建了唯一的一个master 分支，而git commit就是往 master分支上提交更改。也可以简单理解为需要提交的文件修改通通放到了暂存区，等到要提交的时候，一次性提交暂存区里所有的文件到分支。\n\n注意点：\n\ngit diff 是工作区与暂存区的对比\ngit diff -- cached 是暂存区与分支的对比\ngit diff HEAD -- &lt;file&gt; 是工作区与分支的对比\n\n 撤销修改\n在以下三种情况下可以撤销修改：\n\n修改了文件，没有添加到暂存区（修改了工作区）git checkout -- &lt;file&gt;\n修改文件后添加到了暂存区，但是没有提交到分支（修改了暂存区）git reset HEAD &lt;file&gt;  //把暂存区的修改回退到工作区git checkout -- &lt;file&gt;//把工作区的修改撤销\n已经提交到了本地仓库分支，没有同步到远程仓库（版本回退即可）git reset --hard HEAD^\n\n 删除文件以及恢复文件\n当我们使用 rm 命令或者直接在图形界面删除文件后，只是修改了工作区，若先使用 git rm &lt;file&gt; 命令删除文件，此时不仅修改了工作区，还修改了暂存区，此时使用撤销修改的命令还能找回被删除的文件。当删除操作被提交到分支后，只能使用版本回退操作来找回删除的文件。\n注：git rm &lt;file&gt; 命令相当于先执行了rm命令 ，然后把工作区的修改添加到了暂存区，也就是说使用git rm &lt;file&gt;命令后不仅工作区的文件被删除了，也把删除操作添加到了暂存区。这就告诉我们，要想快速删除文件并提交到分支，只需执行git rm &lt;file&gt; 命令后commit就行了，如果想要更加谨慎，可以先使用rm 命令删除工作区中的文件，此时若想要撤销删除可以使用git checkout -- &lt;file&gt; 命令；如果想要添加修改操作到暂存区，使用git rm &lt;file&gt; 命令，到了这一步如果想要撤销删除可以先使用git reset HEAD &lt;file&gt; 命令撤销对暂存区的修改，然后使用 git checkout -- &lt;file&gt;命令来撤销对工作区的修改；如果已经把修改操作提交到了分支，此时想要撤销删除，找回文件则只能使用版本回退操作，即使用git reset --hard HEAD^命令。\n 添加远程库，并保持同步\n\n当我们的系统之前从未使用SSH进行加密传输操作时，我们应该首先在用户主目录下创建SSH Key，因为你的本地Git 仓库和GitHub 仓库之间的传输是通过SSH 加密的。\n\n在Github 上创建一个和本地仓库同名的仓库，要让本地仓库与该远程仓库关联可以使用命令：\n\n1git remote add origin git@server-name:path/repo-name.git\n\n关联后，使用命令git push -u origin master第一次推送master 分支的所有内容\n\n例如：\n\n\n此后，每次本地提交后，要想实现远程仓库的同步，只需使用命令git push origin master推送最新的修改\n\n 从远程仓库克隆\n在合适的目录下使用命令\n1git clone git@server-name:path/repo-name.git\n例如:\n\n 创建与合并分支\n\n创建一个名为dev的分支\n\n1git branch dev\n\n切换到dev分支\n\n1git checkout dev\n\n以上两步可以用一条下面的命令完成\n\n1git checkout -b dev //加上-b 参数表示创建并切\n\n查看分支情况\n\n1git branch //这个命令会列出所有的分支，并且在当前分支上会标注星号*\n\n把dev分支的工作合并分支master上\n\n1git checkout master //首先切换到master分支git merge dev //合并指定分支（dev）到当前分支（master）\n\n删除分支\n\n1git branch -d dev //删除分支 dev\n\n 分支合并时冲突解决\n当我们在两个分支上对同一个文件进行修改，并且修改的内容不一样，此时合并这两个分支时就会产生冲突\n\n此时查看该修改的文件时，就会发现Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，此时我们需要手动修改文件，删除Git的标记，然后将修改后的文件先添加到暂存区，然后提交到分支\n\n提交成功后使用命令：git log --graph --pretty=oneline --abbrev-commit可以看到分支合并图\n 分支管理策略\n通常，合并分支的时候，Git会使用Fast forward模式，当是在这种模式下删除分支后就会丢掉分支的信息，如果我们想要在删除分支后还想在分支历史上看到分支的信息就可以强制禁用Fast forward 模式，此时Git 会在合并分支时生成一个新的commit：强制禁用Fast forward 模式的命令：\n1git merge --no-ff -m 'merge with no-ff' dev //因为本次合并会生成一个commit ，所以需要加上 -m 参数说明\n\n 保存现场，修复bug后恢复\n我们在开发过程中需要经常修复软件中发现的bug，在git中我们就可以通过创建一个临时的分支来修复bug，修复bug后合并分支，然后删除临时分支\n但是如果我们在dev分支上的内容还没提交怎么办，此时我们可以使用命令来保存现场：\n1git stash\n此时再查看Git库的状态就是干净的。当我们在master分支上通过创建临时分支修复bug后，再checkout 回dev分支时，我们有两条命令都可以恢复修复bug之前dev分支的状态：\n12（1）git stash apply // 恢复工作现场，但是不删除现场，就是说以后还可以恢复到该状态（2）git stash pop // 恢复工作现场后删除stash的内容\n我们可以使用命令git stash list 来查看有多少现场被保存了，我们也可以多次使用stash，恢复的时候，通过 list后查看stash 的值， 然后通过恢复现场的命令来选择回到具体哪一个现场，如：\n12(1) git stash apply stash@&#123;1&#125;  //恢复到 stash@&#123;1&#125; 后不删除该现场(2) git stash pop stash@&#123;0&#125; //恢复到 stash@&#123;0&#125; 后删除该现场\n 强行删除没有完全合并的分支\n当我们要添加一个新功能时我们会新建一个分支来进行添加，等到要合并新功能的分支到主分支时，接到通知说该新功能不需要了，此时如果我们删除该新功能分支会提示我们该新功能分支没有完全合并，如果确认要删除它，执行：git branch -D &lt;分支名称&gt;使用这个命令就可以删除未合并的分支，其实就是将小写 d 换成大写D\n 多人协作开发\n我们一般在开发中都是多人协作开发项目的,当你clone你的另一名小伙伴的项目库到你电脑上后，默认你只能看到该项目的本地master分支，你如果想要在dev分支上开发，就必须创建远程origin的dev分支到本地来，使用的命令是：\n1git checkout -b dev origin/dev\n这样你就可以继续在dev上修改，修改完之后还可以 push dev分支到远程库，但是如果你的小伙伴也push了一次到远程库，并且此时你和你的小伙伴都对同样的文件进行了修改，你现在试图推送该分支到远程库，结果出现\n\n推送失败，因为你的提交与你小伙伴的最新提交之间有冲突。此时根据提示我们先用git pull把最新的提交从 origin/dev抓取下来，然后在本地合并解决冲突后然后提交分支并且推送dev到远程库。有的时候，我们git pull也会失败，原因是因为没有指定本地 dev 分支与远程origin/dev 分支的链接。我们根据提示，设置链接\n设置的命令如提示:\n1git branch --set-upstream-to=origin/dev\n此时就可以git pull 了，但是在本地合并时还会有冲突，此时我们通过手动解决冲突后然后推送到远程库。\n\n小结：\n\n查看远程库的信息，使用命令git remote -v\n本地新建的分支如果不推送到远程对其他人是不可见的\n在本地创建和远程分支对应的分支使用git checkout -b branch-name origin/branch-name 本地和远程分支的名称最好一致\n\n 创建和操作标签\n为了更加方便的操作不同的版本，使用commit号（如：fs3k1hgk）是非常不方便的，如果使用版本号如v 1.2等标号就能很快的确认一个版本.\n标签：tag就是一个让人容易记住的有意义的名字，它跟某一个commit 绑在一起。它可以类似的理解为 IP 与域名的关系.\n\n使用如下命令用于新建一个标签，默认为HEAD，也可以指定一个commit id\n\n1234git tag &lt;tagname&gt;如：git tag v1.0git tag &lt;tagname&gt; &lt;commit id&gt;如：git tag v1.0 ew326gd | git tag v 1.0 HEAD@&#123;1&#125;\n\n注:    标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息\n\n删除一个本地标签git tag -d &lt;tagname&gt;\n推送一个本地标签到远程库git push origin &lt;tagname&gt;\n推送全部未推送到远程库的标签到远程库git push origin --tags\n删除一个已经推送到远程库的标签\n\n12git tag -d &lt;tagname&gt; //先删除本地标签git push origin:refs/tags/&lt;tagname&gt; // 再删除远程标签\n 一个本地库关联多个远程库\n由于git本身是分布式版本控制系统，可以同步多个不同的远程库。例如可以同时同步到GitHUb和码云，但是我们在使用多个远程库时要注意，因为git给远程库起的默认名称是origin，如果有多个远程库，我们就需要使用不同的名称来标识不同的远程库。\n一般关联多个远程库分为下面几个步骤：\n\n如果之前关联过一个远程库，且远程库的名称是默认的origin，此时你可以继续保留这个库或者先删除这个库，然后再关联并且起一个更加有辨识度的名称\n\n1git remote rm origin //删除已经关联的名为origin 的远程库\n\n接着再关联如GitHub上的远程库，并将远程库的名称叫做 GitHub,不使用默认的名称\n\n1git remote add github git@github.com:dmego/learngit.git\n\n然后再关联一个远程仓库，如码云上的远程库，并将远程库的名称叫做gitee\n\n1git remote add gitee git@gitee.com:dmocgo/learngit.git\n\n现在，我们用git remote -v查看远程库信息，可以看到两个远程库：\n\n12345git remote -vgitee git@gitee.com:dmocgo/learngit.git (fetch)gitee git@gitee.com:dmocgo/learngit.git (push)github git@github.com:dmego/learngit.git (fetch)github git@github.com:dmego/learngit.git (push)\n\n如果要推送到GitHub，使用命令：\n\n1git push github master\n16. 如果要推送到码云，使用命令：\n1git push gitee master\n这样一来，我们的本地库就可以同时与多个远程库同步\n\n 自定义Git\n\n让Git命令显示颜色，输出更加醒目：\n\n1git config --global color.ui true\n\n忽略特殊的文件，其中忽略文件的原则是：\n\n\n忽略操作系统自动生成的文件，如缩略图\n忽略编译生成的中间文件，可执行文件，也就是说一个文件时通过其他文件自动生成的就没有必要放进版本库了，例如java编译产生的.class 文件\n忽略带有敏感信息的配置文件，比如保存了数据库密码的配置文件\n\n我们在Git工作区的根目录下创建一个特殊的 .gitignore文件，然后把要忽略的文件名写进去，Git就会每次在提交的时候自动忽略这些文件，我们不需要从头写一个.gitignore文件，GitHub已经为我们准备了各种配置文件，所有的配置文件都可以在线浏览：https://github.com/github/gitignore。\n有的时候，你想添加一个文件到git ，但是却发现添加不了，原因可能是这个文件被忽略了，如果想强制添加可以使用命令：\n1git add -f &lt;filename&gt;\n还有的时候发现可能是 .gitignore文件写错了，需要找出来到底哪个规则写错了，可以使用命令检查：\n1git check-ignore -v &lt;filename&gt;\n\n配置别名，简化命令。有时候命令太长或者单词不好记就可以使用Git来配置别名来达到高效的目的，例如将命令git status简化为git st:\n\n1git config --global alias.st status\n注意：\n--global 参数是全局参数，也就是这些命令在这台电脑的所有Git 仓库下都可以使用（是针对当前用户起作用），如果不加这个参数，就只能对当前仓库起作用。\n每个仓库的配置文件都放在.git/config 文件中，其中别名就在 [alias] 后面，要想删除别名直接把对应的那行删除就行了\n而每个用户的配置文件放在用户主目录下的一个隐藏文件.gitconfig中。其中别名就在 [alias]后面，要想删除别名直接把对应的那行删除就行了。\n 搭建Git服务器\n教程地址：廖雪峰GIt教程\n","thumbnail":"2017/08/26/learn-git/2017-08-27_035118.jpg","color":"#111","plink":"https://dmego.me/2017/08/26/learn-git/"},{"title":"汉诺塔的图解递归算法","date":"2016-10-16T01:56:00.000Z","author":"Dmego","updated":"2019-12-22T18:21:32.529Z","content":"\n 起源\n汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。\n 抽象为数学问题\n如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数\n\n解:\n(1)  n == 1\n\n第1次  1号盘  A----&gt;C       sum = 1 次\n\n(2)  n == 2\n\n第1次  1号盘  A----&gt;B\n​  第2次  2号盘  A----&gt;C\n​  第3次  1号盘  B----&gt;C        sum = 3 次\n\n（3）n == 3\n\n第1次  1号盘  A----&gt;C\n​  第2次  2号盘  A----&gt;B\n​  第3次  1号盘  C----&gt;B\n​  第4次  3号盘  A----&gt;C\n​  第5次  1号盘  B----&gt;A\n​  第6次  2号盘  B----&gt;C\n​  第7次  1号盘  A----&gt;C        sum = 7 次\n\n不难发现规律：\n\n1个圆盘的次数 2的1次方减1\n​  2个圆盘的次数 2的2次方减1\n​  3个圆盘的次数 2的3次方减1\n​   。  。   。    。   。\n​  n个圆盘的次数 2的n次方减1\n\n故：移动次数为：2^n - 1\n 调用方法的栈机制（特点：先进后出）\n从主线程开始调用方法（函数）进行不停的压栈和出栈操作，函数的调用就是将函数压如栈中，函数的结束就是函数出栈的过程，这样就保证了方法调用的顺序流，即当函数出现多层嵌套时，需要从外到内一层层把函数压入栈中，最后栈顶的函数先执行结束（最内层的函数先执行结束）后出栈，再倒数第二层的函数执行结束出栈，到最后，第一个进栈的函数调用结束后从栈中弹出回到主线程，并且结束。\n 算法分析（递归算法）\n我们在利用计算机求汉诺塔问题时，必不可少的一步是对整个实现求解进行算法分析。到目前为止，求解汉诺塔问题最简单的算法还是同过递归来求，至于是什么是递归，递归实现的机制是什么，我们说的简单点就是自己是一个方法或者说是函数，但是在自己这个函数里有调用自己这个函数的语句，而这个调用怎么才能调用结束呢？，这里还必须有一个结束点，或者具体的说是在调用到某一次后函数能返回一个确定的值，接着倒数第二个就能返回一个确定的值，一直到第一次调用的这个函数能返回一个确定的值。\n实现这个算法可以简单分为三个步骤：\n\n（1）     把n-1个盘子由A 移到 B；\n（2）     把第n个盘子由 A移到 C；\n（3）     把n-1个盘子由B 移到 C；\n\n从这里入手，在加上上面数学问题解法的分析，我们不难发现，移到的步数必定为奇数步：\n\n（1）中间的一步是把最大的一个盘子由A移到C上去；\n（2）中间一步之上可以看成把A上n-1个盘子通过借助辅助塔（C塔）移到了B上，\n（3）中间一步之下可以看成把B上n-1个盘子通过借助辅助塔（A塔）移到了C上；\n\n java源代码\n123456789101112131415161718192021222324252627282930313233343536373839404142package demo;/** * 目的：实现汉诺塔问题求解 * 作者：Dmego  时间：2016-10-15 */import java.util.Scanner;public class TowersOfHanoi &#123;    static int m =0;//标记移动次数    //实现移动的函数    public static void move(int disks,char N,char M)    &#123;        System.out.println(\"第\" + (++m) +\" 次移动 : \" +\" 把 \"+ disks+\" 号圆盘从 \" + N +\" -&gt;移到-&gt;  \" + M);    &#125;    //递归实现汉诺塔的函数    public static void hanoi(int n,char A,char B,char C)    &#123;        if(n == 1)//圆盘只有一个时，只需将其从A塔移到C塔            TowersOfHanoi.move(1, A, C);//将编b号为1的圆盘从A移到C        else        &#123;//否则            hanoi(n - 1, A, C, B);//递归，把A塔上编号1~n-1的圆盘移到B上，以C为辅助塔            TowersOfHanoi.move(n, A, C);//把A塔上编号为n的圆盘移到C上            hanoi(n - 1, B, A, C);//递归，把B塔上编号1~n-1的圆盘移到C上，以A为辅助塔        &#125;    &#125;    public static void main(String[] args) &#123;        Scanner imput = new Scanner(System.in);        char A = 'A';        char B = 'B';        char C = 'C';        System.out.println(\"******************************************************************************************\");        System.out.println(\"这是汉诺塔问题（把A塔上编号从小号到大号的圆盘从A塔通过B辅助塔移动到C塔上去\");        System.out.println(\"******************************************************************************************\");        System.out.print(\"请输入圆盘的个数：\");        int disks = imput.nextInt();        TowersOfHanoi.hanoi(disks, A, B, C);        System.out.println(\"&gt;&gt;移动了\" + m + \"次，把A上的圆盘都移动到了C上\");        imput.close();    &#125;&#125;\n 图解程序运行流程\n\n（1）函数hanoi(int n,char A,char B,char C)的功能是把编号为n的圆盘借助B从A移动到 C上。\n（2）函数move(int n ,char N ,char M)的功能是把1编号为n的圆盘从N 移到M上\n\n\n 程序运行截图\n\n","plink":"https://dmego.me/2016/10/16/hanoi/"},{"title":"About Me","date":"2019-12-22T18:21:32.553Z","updated":"2019-12-22T18:21:32.553Z","content":"123456789101112131415161718192021222324252627&#123;  name: 'Dmego'  age: 22,  gender: 'Boy',  profession: 'Backend Developer &amp; Geek',  address: 'Beijing',  github: 'https://github.com/dmego',  blog: 'https://dmego.me',  email: 'dmeago@gmail.com',  description: '后端开发，极客生活',  skills: [    ['Java', 'Spring', 'Python', 'Linux', 'SQL'],    ['SSH','SSM','Spring Boot'],    ['Hadoop','Hive','Hbase','Spark'],    ['HyperLedger Fabric','Docker'],    ['JavaScript', 'JQuery','HTML+CSS','Bootstrap'],    ['Git', 'SVN']  ],  devTools: [    ['Eclipse &amp; MyEclipse', 'IDEA']    ['Visual Studio Code', 'Sublime Text','NotePad++'],    ['Chrome DevTools'],    ['Navicat', 'SQLyog','SQLDeveloper']  ]  &#125;\n","plink":"https://dmego.me/about/"},{"title":"Links","date":"2019-12-22T18:21:32.553Z","updated":"2019-12-22T18:21:32.553Z","content":"123456789101112Wang Mao:  link: https://blog.wangmao.me/  desc: 路漫漫其修远兮，吾将上下而求索Scriptboy:  link: https://scriptboy.cn/  desc: 在生活中向雷锋学习，在工作中与...Luotf:  link: http://www.luotf.com/  desc: 罗廷方博客mongona:  link: https://www.mongona.com/  desc: life is short, you need...\n","plink":"https://dmego.me/links/"}]