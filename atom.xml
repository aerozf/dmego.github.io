<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dmego的博客</title>
  <subtitle>Code create life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dmego.me/"/>
  <updated>2017-09-29T15:01:38.286Z</updated>
  <id>http://dmego.me/</id>
  
  <author>
    <name>木青子日</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何做好需求分析</title>
    <link href="http://dmego.me/2017/09/29/good_demand_and_analysis.html"/>
    <id>http://dmego.me/2017/09/29/good_demand_and_analysis.html</id>
    <published>2017-09-29T14:56:00.000Z</published>
    <updated>2017-09-29T15:01:38.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这学期的《软件需求与分析》课可以说是软件工程专业比较重要的一门课。如何做好软件需求分析就等同于如何做好一个项目。客户对需求一改再改，如果我们只是一味的去抱怨，而不去思考客户对需求更改的原因是什么，不了解业务，那我们做出来的产品肯定得不到客户的认可。<br>通过阅读<a href="http://fangang.iteye.com/blog/1345099" target="_blank" rel="external">我们应当怎样做需求分析</a>这一系列的文章，我总结出来做好软件需求分析需求从这几方面入手。首先是做需求调研，就是采集需求这个阶段，在这个阶段其实是一个反复循环的过程：需求捕获——需求整理——需求验证——再需求捕获……；在每一次做完需求调研后就要做一次需求分析，并且等到下一次去做需求调研时，我们应该首先将上一次的需求分析结果与客户进行确认。然而在每次的需求分析阶段其实也是一个比较复杂的分析过程，我们需求画大量的UML图（例如用例图），对角色功能进行分析，对业务流程进行分析等。最后我们还需要做好需求确认工作，写好需求规格说明书然后评审签字确认。</p>
<h2 id="要点提炼"><a href="#要点提炼" class="headerlink" title="要点提炼"></a>要点提炼</h2><p>许多需求分析工作都是从需求调研开始的，需求调研工作既是一份技术活更是一份体力活。它要求我们具有一种理解能力，设计能力，更要求我们具有一种与人交往与沟通的能力。<br><a id="more"></a></p>
<h3 id="开研讨会捕获需求"><a href="#开研讨会捕获需求" class="headerlink" title="开研讨会捕获需求"></a>开研讨会捕获需求</h3><p>我们需求获得客户的需求，必须要了解业务，要想了解业务，一是可以学习相关的知识，最有效的方法就是开业务研讨会，需求研讨会等，在会上我们不但可以更好的和客户交流整个流程，还可以讨论一些比较细节的地方。但是在组织研讨会的同时必须注意两点：有效抑制个性化差异，分模块组织专项研讨会。</p>
<h3 id="学会需求捕获"><a href="#学会需求捕获" class="headerlink" title="学会需求捕获"></a>学会需求捕获</h3><p>整个需求分析过程是一个迭代的过程，在需求捕获这个阶段，往往不是考验我们的专业知识，而是涉及人际交往，沟通理解等方面。如果学会了如何捕获客户的需求，那我们的项目成功的概率就会得到质的飞跃。在学会捕获需求之前我们要清楚的认识到软件需求不仅仅是客户嘴里说出来的。还有两类需求需要我们自己去发现：一是客户嘴里没有说的需求，二是客户压根没有想到的需求。知道这些后如果我们不能更好的处理与客户交流的方式，那一切都是百搭，在与客户讨论需求过程中，态度决定一切，既不能让自己处于被动状态，对客户提出的所有需求都记下来然后不加分析地给开发人员；也不能盲目主动，不分析客户的需求，按照自己的想法来，最后交付的时候客户说这不是自己想要的软件。最明智的做法是先跟客户谈业务，先谈论业务流程，在此阶段我们还要多问为什么，这样可以让我们深入地了解这些领域的知识，站在客户的角度去思考问题，进而能够深入理解客户为什么要提出他们的那些业务需求。</p>
<h3 id="功能角色分析"><a href="#功能角色分析" class="headerlink" title="功能角色分析"></a>功能角色分析</h3><p>当我们经过一番忙碌，将需求中的第一手资料从调研现场捕获回来后我们就要对需求进行行之有效的分析，而这种分析首先应当从功能角色分析开始，所谓的功能角色分析就是从一个外部用户的视角分析整个软件系统能够提供的功能，以及这些功能到底提供给那些角色使用。而对一个系统进行功能和角色方面的梳理和分析，可以采用画用例图的方法。运用这种方法对业务需求进行分析、抽象、整理、提炼进而形成用例模型。<br>我们在画用例图的过程中不能以一个开发者的角色来绘制，许多描述信息也绝不能按照开发者的思维和习惯去写，而是要贴近客户，因为用例图的视角是用户。所以描述信息应该迎合用户平时的习惯用语。</p>
<h3 id="业务流程分析"><a href="#业务流程分析" class="headerlink" title="业务流程分析"></a>业务流程分析</h3><p>做好角色分析后，最重要的一步就是要做好业务流程分析。文章作者在这一章中用了许多例子来说明问题，在分析ERP对企业流程改进的例子中，作者分析出来的思路是清除低效环节、简化业务瓶颈、整合可用资源，以及将繁琐任务自动化。计算机信息化管理并不是万能的，它并不能代替现实世界中的所有工作。因此我们进行业务流程分析，就是要分析业务流程中哪些是需要信息化管理的，而哪些则不需要。另外，业务流程分析的另一个重要的分析内容就是流程差异化分析。不同的领导有不同的思路，不同的单位有不同的情况。因此，我们在进行流程分析的时候，常常面临流程差异化的问题。</p>
<h3 id="业务领域分析"><a href="#业务领域分析" class="headerlink" title="业务领域分析"></a>业务领域分析</h3><p>在需求分析工作中，最后一项分析工作就是业务领域分析啦。业务领域分析，就是对需求分析中涉及到的业务实体，以及它们相互之间关联关系的分析。什么叫业务领域，就是客户所在的知识领域，譬如财务人员所在的是财务领域，税务人员所在的是税务领域。不同的知识领域拥有各自不同的领域知识，需求分析人员就应该通过客户中的领域专家去学习这些知识、掌握这些要点，并最终体现在我们的需求分析中。我们进行业务领域分析，就是通过与用户进行交流，掌握领域知识，然后绘制成业务领域模型，去指导我们软件开发的过程。其中，我们可以通过两种分析方法一步步进行分析：原文分析法与领域驱动设计。</p>
<h3 id="挖掘非功能需求"><a href="#挖掘非功能需求" class="headerlink" title="挖掘非功能需求"></a>挖掘非功能需求</h3><p>需求分析人员最容易忽略的部分就是非功能需求。非功能需求更加靠近的是技术，是设计，是实现，是架构师关注的内容，是需求人员最不擅长的方面，这也是非功能需求为什么常常被忽略的重要原因。正因为如此，架构师应当尽早参与到项目中，参与到需求分析中，尽早分析需求的技术可行性，尽早考虑性能、安全性、可靠性等非功能需求，尽早开始架构设计。 非功能需求可以简单归纳为“URPS+”，即可用性（Usability）、可靠性（Reliability）、性能（Performance）、可支持性（Supportability）以及其它（+）。，将我们分析出来的功能中所潜在的、特殊的非功能需求挖掘出来，提前进行分析设计，对于可行性不高的应及时与客户商讨，才能有效地避免日后存在的这些方面的风险。 </p>
<h3 id="做好需求列表"><a href="#做好需求列表" class="headerlink" title="做好需求列表"></a>做好需求列表</h3><p>需求列表，又称之为需求跟踪表，是最原始的、用户对业务需求的描述。它不掺杂任何需求分析人员对业务需求的分析与设计，而是以简短扼要的语句，以业务人员的口吻表述的，今后要开发的这个系统应当提供给他们的各项功能。 首先，需求列表不掺杂我们对业务需求的任何分析与设计，这是需求列表的核心，也是它存在的意义。其次，需求列表应当是站在业务人员的视角，对业务需求的简明扼要的描述。在需求列表中应当剔除那些客户对系统设计的内容。最后，需求列表也不是一步到位的，而是经过由粗到细逐渐整理形成的。</p>
<h3 id="写好需求规格说明书"><a href="#写好需求规格说明书" class="headerlink" title="写好需求规格说明书"></a>写好需求规格说明书</h3><p>我们之所以要编写自己的需求规格说明书，就是要本着实事求是、切实可行的态度，去描述用户的业务需求。那些不可行的需求被摒弃，或者换成更加可行的解决方案。这就是需求规格说明书的重要作用。领域驱动设计所提倡的就是要让用户、需求分析员、开发人员站在一个平台，使用统一的语言（一种混合语言），来表达大家都清楚明白的概念 。我们不能拿着用户编写的原始需求就开始开发，只有依据自己的公司、项目、特别是需求分析中采用的方法，写出一份既是从用户角度描述的系统业务需求说明书，又是一份指导开发人员完成设计与开发的技术性文档。</p>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="http://ovasw3yf9.bkt.clouddn.com/blog/170929/630eE0Aecg.png?imageslim" alt="mark"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这学期的《软件需求与分析》课可以说是软件工程专业比较重要的一门课。如何做好软件需求分析就等同于如何做好一个项目。客户对需求一改再改，如果我们只是一味的去抱怨，而不去思考客户对需求更改的原因是什么，不了解业务，那我们做出来的产品肯定得不到客户的认可。&lt;br&gt;通过阅读&lt;a href=&quot;http://fangang.iteye.com/blog/1345099&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我们应当怎样做需求分析&lt;/a&gt;这一系列的文章，我总结出来做好软件需求分析需求从这几方面入手。首先是做需求调研，就是采集需求这个阶段，在这个阶段其实是一个反复循环的过程：需求捕获——需求整理——需求验证——再需求捕获……；在每一次做完需求调研后就要做一次需求分析，并且等到下一次去做需求调研时，我们应该首先将上一次的需求分析结果与客户进行确认。然而在每次的需求分析阶段其实也是一个比较复杂的分析过程，我们需求画大量的UML图（例如用例图），对角色功能进行分析，对业务流程进行分析等。最后我们还需要做好需求确认工作，写好需求规格说明书然后评审签字确认。&lt;/p&gt;
&lt;h2 id=&quot;要点提炼&quot;&gt;&lt;a href=&quot;#要点提炼&quot; class=&quot;headerlink&quot; title=&quot;要点提炼&quot;&gt;&lt;/a&gt;要点提炼&lt;/h2&gt;&lt;p&gt;许多需求分析工作都是从需求调研开始的，需求调研工作既是一份技术活更是一份体力活。它要求我们具有一种理解能力，设计能力，更要求我们具有一种与人交往与沟通的能力。&lt;br&gt;
    
    </summary>
    
      <category term="软件需求与分析" scheme="http://dmego.me/categories/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="阅读笔记" scheme="http://dmego.me/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>System Error. Code:1722. RPC服务器不可用解决办法</title>
    <link href="http://dmego.me/2017/09/25/starUML_error.html"/>
    <id>http://dmego.me/2017/09/25/starUML_error.html</id>
    <published>2017-09-25T03:30:00.000Z</published>
    <updated>2017-09-29T16:12:00.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近在软件设计上机课的时候，使用 starUML 建模工具画UML图的时候总是弹出一条如下信息<br><img src="http://ovasw3yf9.bkt.clouddn.com/blog/170929/gfcIkb2hKC.png?imageslim" alt="mark"><br>虽然是错误，但是点击确定后软件能正常使用，可是这样还是不太好。一般来说出现这种错误应该是某个windows 服务没有打开而导致的问题。<br><a id="more"></a></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>经过上网查资料，发现只要打开RPCSS服务就可以了，可是我却发现我这里RPCSS服务是正在运行，既是重启也不管用。<br><img src="http://ovasw3yf9.bkt.clouddn.com/blog/170929/ACjE3Gaj91.png?imageslim" alt="mark"><br>没有办法，继续查资料，最后发现原来是 Print Spooler 这个服务没有启动,只要启动这个服务就可以了。于是我在服务里看，原来这个服务真的是关闭状态，而且还是禁用。<br><img src="http://ovasw3yf9.bkt.clouddn.com/blog/170929/JE6g3C2LfD.png?imageslim" alt="mark"><br>将这个服务改启动为自动，并且启动后发现再次打开 starUML 的时候没有报错</p>
<h2 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h2><p>但是我这里为什么 Print Spooler 服务是禁用的呢，经过回想，发现之前我嫌win 10 有太多无用的服务，于是就关闭了不少，其中就包括这里的 Print Spooler 服务（与打印有关的服务）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;最近在软件设计上机课的时候，使用 starUML 建模工具画UML图的时候总是弹出一条如下信息&lt;br&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/170929/gfcIkb2hKC.png?imageslim&quot; alt=&quot;mark&quot;&gt;&lt;br&gt;虽然是错误，但是点击确定后软件能正常使用，可是这样还是不太好。一般来说出现这种错误应该是某个windows 服务没有打开而导致的问题。&lt;br&gt;
    
    </summary>
    
      <category term="软件问题解决" scheme="http://dmego.me/categories/%E8%BD%AF%E4%BB%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="starUML" scheme="http://dmego.me/tags/starUML/"/>
    
      <category term="RPC服务器" scheme="http://dmego.me/tags/RPC%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记</title>
    <link href="http://dmego.me/2017/08/26/learn-git.html"/>
    <id>http://dmego.me/2017/08/26/learn-git.html</id>
    <published>2017-08-26T02:36:00.000Z</published>
    <updated>2017-09-29T14:55:50.996Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ovas9vc9a.bkt.clouddn.com/2017-08-27_035118.jpg" alt="img"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>本文档笔记是本人通过学习<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰Git教程</a>的整理而来</p>
</li>
<li><p>本文档主要记录本人当时在学习过程中认为重要的概念和命令</p>
</li>
</ul>
<h2 id="创建一个版本库"><a href="#创建一个版本库" class="headerlink" title="创建一个版本库"></a>创建一个版本库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir learngit //使用命令创建一个目录</div><div class="line">cd learngit //进入这个目录</div><div class="line">pwd //用于显示当前目录</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure>
<h2 id="添加文件到仓库"><a href="#添加文件到仓库" class="headerlink" title="添加文件到仓库"></a>添加文件到仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">第一步：git add &lt;file&gt;</div><div class="line">第二步：git commit -m &apos;本次提交的说明&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git status:查看当前Git仓库的状态，是否有文件没有提交，让我们掌握仓库最新的状态</div><div class="line">git diff: 查看不同，当修改文件后，可以查看修改了什么内容（只适用于文本文件）</div></pre></td></tr></table></figure>
<p><img src="http://ovas9vc9a.bkt.clouddn.com/11113c.png" alt="img"></p>
<h2 id="实现版本之间回退"><a href="#实现版本之间回退" class="headerlink" title="实现版本之间回退"></a>实现版本之间回退</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git log:显示从最近到最远的提交日志</div><div class="line">git log --pretty=oneline:如果信息太多，使用这行命令</div></pre></td></tr></table></figure>
<ol>
<li>在Git中，用<code>HEAD</code>表示当前版本,上一个版本就是<code>HEAD^</code>，上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</li>
<li>一大串类似<code>882e1e0...67hko896</code>的是commit id 版本号</li>
<li><code>git reset --hard HEAD^</code>: 回退到上一个版本此时，当再次使用<code>git log</code>命令时，发现之前的版本已经消失了，此时想要再次回到那个版本，有两种方式：一种是当命令窗口没有关闭时，找到那个版本的版本号，如：<code>81ac3c5</code>，此时又回到最新的那个版本的命令是：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard 81ac3c5</div></pre></td></tr></table></figure>
<p>如果已经过去很久了，已经记不得想要回退的版本的ID号，此时可以依据这个命令来找回版本号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure></p>
<p><img src="http://ovas9vc9a.bkt.clouddn.com/54bef601-1354-4439-b2fa-3a416a9a0e58.png" alt="img"></p>
<h2 id="工作区与暂存区的概念"><a href="#工作区与暂存区的概念" class="headerlink" title="工作区与暂存区的概念"></a>工作区与暂存区的概念</h2><ol>
<li><p>工作区（Working Directory）：就是能在电脑上看到的目录，比如仓库文件夹</p>
</li>
<li><p>版本库（Repository）：工作区里有一个隐藏目录<code>.git</code> ，这个不算工作区，而是git的版本库前面我们讲了往Git版本库里添加文件的时候，分两步，这两步更详细的说是：</p>
<ul>
<li><p>第一步使用<code>git add</code> 把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
</li>
<li><p>第二步使用<code>git commit</code>提交修改，实际上是把暂存区的所有内容提交到当前分支因为我们创建Git版本库的时候，Git自动为我们创建了唯一的一个<code>master</code> 分支，而<code>git commit</code>就是往 <code>master</code>分支上提交更改。也可以简单理解为需要提交的文件修改通通放到了暂存区，等到要提交的时候，一次性提交暂存区里所有的文件到分支。</p>
</li>
</ul>
</li>
</ol>
<p><strong>注意点</strong>：</p>
<blockquote>
<p><code>git diff</code> 是工作区与暂存区的对比<br><code>git diff -- cached</code> 是暂存区与分支的对比<br><code>git diff HEAD -- &lt;file&gt;</code> 是工作区与分支的对比</p>
</blockquote>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p><em>在以下三种情况下可以撤销修改：</em></p>
<ol>
<li>修改了文件，没有添加到暂存区（修改了工作区）<code>git checkout -- &lt;file&gt;</code></li>
<li>修改文件后添加到了暂存区，但是没有提交到分支（修改了暂存区）<code>git reset HEAD &lt;file&gt;</code>  //把暂存区的修改回退到工作区<code>git checkout -- &lt;file&gt;</code>//把工作区的修改撤销</li>
<li>已经提交到了本地仓库分支，没有同步到远程仓库（版本回退即可）<code>git reset --hard HEAD^</code></li>
</ol>
<h2 id="删除文件以及恢复文件"><a href="#删除文件以及恢复文件" class="headerlink" title="删除文件以及恢复文件"></a>删除文件以及恢复文件</h2><p>当我们使用 <code>rm</code> 命令或者直接在图形界面删除文件后，只是修改了工作区，若先使用 <code>git rm &lt;file&gt;</code> 命令删除文件，此时不仅修改了工作区，还修改了暂存区，此时使用撤销修改的命令还能找回被删除的文件。当删除操作被提交到分支后，只能使用版本回退操作来找回删除的文件。</p>
<p><strong>注</strong>：<code>git rm &lt;file&gt;</code> 命令相当于先执行了<code>rm</code>命令 ，然后把工作区的修改添加到了暂存区，也就是说使用<code>git rm &lt;file&gt;</code>命令后不仅工作区的文件被删除了，也把删除操作添加到了暂存区。这就告诉我们，要想快速删除文件并提交到分支，只需执行<code>git rm &lt;file&gt;</code> 命令后<code>commit</code>就行了，如果想要更加谨慎，可以先使用<code>rm</code> 命令删除工作区中的文件，此时若想要撤销删除可以使用<code>git checkout -- &lt;file&gt;</code> 命令；如果想要添加修改操作到暂存区，使用<code>git rm &lt;file&gt;</code> 命令，到了这一步如果想要撤销删除可以先使用<code>git reset HEAD &lt;file&gt;</code> 命令撤销对暂存区的修改，然后使用 <code>git checkout -- &lt;file&gt;</code>命令来撤销对工作区的修改；如果已经把修改操作提交到了分支，此时想要撤销删除，找回文件则只能使用版本回退操作，即使用<code>git reset --hard HEAD^</code>命令。</p>
<h2 id="添加远程库，并保持同步"><a href="#添加远程库，并保持同步" class="headerlink" title="添加远程库，并保持同步"></a>添加远程库，并保持同步</h2><ol>
<li><p>当我们的系统之前从未使用SSH进行加密传输操作时，我们应该首先在用户主目录下创建SSH Key，因为你的本地Git 仓库和GitHub 仓库之间的传输是通过SSH 加密的。<br><img src="http://ovas9vc9a.bkt.clouddn.com/c4330f33-1538-4ae2-bd4d-bca9ab4c8dd0.png" alt="img"></p>
</li>
<li><p>在Github 上创建一个和本地仓库同名的仓库，要让本地仓库与该远程仓库关联可以使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@server-name:path/repo-name.git</div></pre></td></tr></table></figure>
</li>
<li><p>关联后，使用命令<code>git push -u origin master</code>第一次推送<code>master</code> 分支的所有内容<br>例如：<br><img src="http://ovas9vc9a.bkt.clouddn.com/f6f278e2-fda1-4021-885b-4a7ef7c9a776.png" alt="img"></p>
</li>
<li><p>此后，每次本地提交后，要想实现远程仓库的同步，只需使用命令<code>git push origin master</code>推送最新的修改</p>
</li>
</ol>
<h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><p>在合适的目录下使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@server-name:path/repo-name.git</div></pre></td></tr></table></figure></p>
<p>例如:<br><img src="http://ovas9vc9a.bkt.clouddn.com/533ef804-c1e6-4252-bd52-af787ccfa4a3.png" alt="img"></p>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><ol>
<li><p>创建一个名为<code>dev</code>的分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch dev</div></pre></td></tr></table></figure>
</li>
<li><p>切换到<code>dev</code>分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout dev</div></pre></td></tr></table></figure>
</li>
<li><p>以上两步可以用一条下面的命令完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b dev //加上-b 参数表示创建并切</div></pre></td></tr></table></figure>
</li>
<li><p>查看分支情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch //这个命令会列出所有的分支，并且在当前分支上会标注星号*</div></pre></td></tr></table></figure>
</li>
<li><p>把<code>dev</code>分支的工作合并分支<code>master</code>上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout master //首先切换到master分支git merge dev //合并指定分支（dev）到当前分支（master）</div></pre></td></tr></table></figure>
</li>
<li><p>删除分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d dev //删除分支 dev</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://ovas9vc9a.bkt.clouddn.com/31ee3b6d-f1a8-446b-a80b-5d674c018591.png" alt="img"></p>
<h2 id="分支合并时冲突解决"><a href="#分支合并时冲突解决" class="headerlink" title="分支合并时冲突解决"></a>分支合并时冲突解决</h2><p>当我们在两个分支上对同一个文件进行修改，并且修改的内容不一样，此时合并这两个分支时就会产生冲突<br><img src="http://ovas9vc9a.bkt.clouddn.com/a432bb77-8466-442e-99cd-859ba52730ee.png" alt="img"><br>此时查看该修改的文件时，就会发现Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，此时我们需要手动修改文件，删除Git的标记，然后将修改后的文件先添加到暂存区，然后提交到分支<br><img src="http://ovas9vc9a.bkt.clouddn.com/ccdf2ba4-ce17-4c54-b347-63ec55776dc7.png" alt="img"><br>提交成功后使用命令：<code>git log --graph --pretty=oneline --abbrev-commit</code>可以看到分支合并图</p>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支的时候，Git会使用<code>Fast forward</code>模式，当是在这种模式下删除分支后就会丢掉分支的信息，如果我们想要在删除分支后还想在分支历史上看到分支的信息就可以强制禁用<code>Fast forward</code> 模式，此时Git 会在合并分支时生成一个新的<code>commit</code>：强制禁用<code>Fast forward</code> 模式的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --no-ff -m &apos;merge with no-ff&apos; dev //因为本次合并会生成一个commit ，所以需要加上 -m 参数说明</div></pre></td></tr></table></figure></p>
<p><img src="http://ovas9vc9a.bkt.clouddn.com/6646c24c-28fb-438b-a683-c3d8febd3be3.png" alt="img"></p>
<h2 id="保存现场，修复bug后恢复"><a href="#保存现场，修复bug后恢复" class="headerlink" title="保存现场，修复bug后恢复"></a>保存现场，修复bug后恢复</h2><p>我们在开发过程中需要经常修复软件中发现的bug，在git中我们就可以通过创建一个临时的分支来修复bug，修复bug后合并分支，然后删除临时分支<br>但是如果我们在<code>dev</code>分支上的内容还没提交怎么办，此时我们可以使用命令来保存现场：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash</div></pre></td></tr></table></figure></p>
<p>此时再查看Git库的状态就是干净的。当我们在<code>master</code>分支上通过创建临时分支修复bug后，再<code>checkout</code> 回<code>dev</code>分支时，我们有两条命令都可以恢复修复bug之前<code>dev</code>分支的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（1）git stash apply // 恢复工作现场，但是不删除现场，就是说以后还可以恢复到该状态</div><div class="line">（2）git stash pop // 恢复工作现场后删除stash的内容</div></pre></td></tr></table></figure></p>
<p>我们可以使用命令<code>git stash list</code> 来查看有多少现场被保存了，我们也可以多次使用<code>stash</code>，恢复的时候，通过 <code>list</code>后查看<code>stash</code> 的值， 然后通过恢复现场的命令来选择回到具体哪一个现场，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(1) git stash apply stash@&#123;1&#125;  //恢复到 stash@&#123;1&#125; 后不删除该现场</div><div class="line">(2) git stash pop stash@&#123;0&#125; //恢复到 stash@&#123;0&#125; 后删除该现场</div></pre></td></tr></table></figure></p>
<h2 id="强行删除没有完全合并的分支"><a href="#强行删除没有完全合并的分支" class="headerlink" title="强行删除没有完全合并的分支"></a>强行删除没有完全合并的分支</h2><p>当我们要添加一个新功能时我们会新建一个分支来进行添加，等到要合并新功能的分支到主分支时，接到通知说该新功能不需要了，此时如果我们删除该新功能分支会提示我们该新功能分支没有完全合并，如果确认要删除它，执行：<code>git branch -D &lt;分支名称&gt;</code>使用这个命令就可以删除未合并的分支，其实就是将小写 <code>d</code> 换成大写<code>D</code></p>
<h2 id="多人协作开发"><a href="#多人协作开发" class="headerlink" title="多人协作开发"></a>多人协作开发</h2><p>我们一般在开发中都是多人协作开发项目的,当你<code>clone</code>你的另一名小伙伴的项目库到你电脑上后，默认你只能看到该项目的本地<code>master</code>分支，你如果想要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地来，使用的命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b dev origin/dev</div></pre></td></tr></table></figure></p>
<p>这样你就可以继续在<code>dev</code>上修改，修改完之后还可以 <code>push dev</code>分支到远程库，但是如果你的小伙伴也<code>push</code>了一次到远程库，并且此时你和你的小伙伴都对同样的文件进行了修改，你现在试图推送该分支到远程库，结果出现<br><img src="http://ovas9vc9a.bkt.clouddn.com/32e277ac-2e9b-4a17-bd62-d793ba27944d.png" alt="img"><br>推送失败，因为你的提交与你小伙伴的最新提交之间有冲突。此时根据提示我们先用<code>git pull</code>把最新的提交从 <code>origin/dev</code>抓取下来，然后在本地合并解决冲突后然后提交分支并且推送<code>dev</code>到远程库。有的时候，我们<code>git pull</code>也会失败，原因是因为没有指定本地 <code>dev</code> 分支与远程<code>origin/dev</code> 分支的链接。我们根据提示，设置链接<br>  设置的命令如提示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch --set-upstream-to=origin/dev</div></pre></td></tr></table></figure></p>
<p>此时就可以<code>git pull</code> 了，但是在本地合并时还会有冲突，此时我们通过手动解决冲突后然后推送到远程库。<br><img src="http://ovas9vc9a.bkt.clouddn.com/ccd6447e-dfe5-4bad-a37f-a9c087187ee2.png" alt="img"><br><strong>小结</strong>：</p>
<ul>
<li>查看远程库的信息，使用命令<code>git remote -v</code></li>
<li>本地新建的分支如果不推送到远程对其他人是不可见的</li>
<li>在本地创建和远程分支对应的分支使用<code>git checkout -b branch-name origin/branch-name</code> 本地和远程分支的名称最好一致</li>
</ul>
<h2 id="创建和操作标签"><a href="#创建和操作标签" class="headerlink" title="创建和操作标签"></a>创建和操作标签</h2><p>为了更加方便的操作不同的版本，使用<code>commit</code>号（如：<code>fs3k1hgk</code>）是非常不方便的，如果使用版本号如<code>v 1.2</code>等标号就能很快的确认一个版本.<br>标签：<code>tag</code>就是一个让人容易记住的有意义的名字，它跟某一个<code>commit</code> 绑在一起。它可以类似的理解为 IP 与域名的关系. </p>
<ol>
<li>使用如下命令用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个<code>commit id</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git tag &lt;tagname&gt; </div><div class="line">如：git tag v1.0</div><div class="line">git tag &lt;tagname&gt; &lt;commit id&gt; </div><div class="line">如：git tag v1.0 ew326gd | git tag v 1.0 HEAD@&#123;1&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://ovas9vc9a.bkt.clouddn.com/c69682ce-7885-4f36-82ae-abfd42deec28.png" alt="img"></p>
<p><em>注:    标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息</em></p>
<ol>
<li>删除一个本地标签<code>git tag -d &lt;tagname&gt;</code></li>
<li>推送一个本地标签到远程库<code>git push origin &lt;tagname&gt;</code></li>
<li>推送全部未推送到远程库的标签到远程库<code>git push origin --tags</code></li>
<li>删除一个已经推送到远程库的标签<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git tag -d &lt;tagname&gt; //先删除本地标签</div><div class="line">git push origin:refs/tags/&lt;tagname&gt; // 再删除远程标签</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="一个本地库关联多个远程库"><a href="#一个本地库关联多个远程库" class="headerlink" title="一个本地库关联多个远程库"></a>一个本地库关联多个远程库</h2><p>由于git本身是分布式版本控制系统，可以同步多个不同的远程库。例如可以同时同步到GitHUb和码云，但是我们在使用多个远程库时要注意，因为git给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们就需要使用不同的名称来标识不同的远程库。<br>一般关联多个远程库分为下面几个步骤： </p>
<ol>
<li><p>如果之前关联过一个远程库，且远程库的名称是默认的<code>origin</code>，此时你可以继续保留这个库或者先删除这个库，然后再关联并且起一个更加有辨识度的名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rm origin //删除已经关联的名为origin 的远程库</div></pre></td></tr></table></figure>
</li>
<li><p>接着再关联如GitHub上的远程库，并将远程库的名称叫做 GitHub,不使用默认的名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add github git@github.com:dmego/learngit.git</div></pre></td></tr></table></figure>
</li>
<li><p>然后再关联一个远程仓库，如码云上的远程库，并将远程库的名称叫做gitee </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add gitee git@gitee.com:dmocgo/learngit.git</div></pre></td></tr></table></figure>
</li>
<li><p>现在，我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git remote -v</div><div class="line">gitee git@gitee.com:dmocgo/learngit.git (fetch)</div><div class="line">gitee git@gitee.com:dmocgo/learngit.git (push)</div><div class="line">github git@github.com:dmego/learngit.git (fetch)</div><div class="line">github git@github.com:dmego/learngit.git (push)</div></pre></td></tr></table></figure>
</li>
<li><p>如果要推送到GitHub，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push github master</div></pre></td></tr></table></figure>
</li>
<li><p>如果要推送到码云，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push gitee master</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样一来，我们的本地库就可以同时与多个远程库同步<br><img src="http://ovas9vc9a.bkt.clouddn.com/m.jpg" alt="img"></p>
<h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><ol>
<li><p>让Git命令显示颜色，输出更加醒目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global color.ui true</div></pre></td></tr></table></figure>
</li>
<li><p>忽略特殊的文件，其中忽略文件的原则是：</p>
<blockquote>
<p>忽略操作系统自动生成的文件，如缩略图<br>忽略编译生成的中间文件，可执行文件，也就是说一个文件时通过其他文件自动生成的就没有必要放进版本库了，例如java编译产生的<code>.class</code> 文件<br>忽略带有敏感信息的配置文件，比如保存了数据库密码的配置文件</p>
</blockquote>
</li>
</ol>
<p>我们在Git工作区的根目录下创建一个特殊的 <code>.gitignore</code>文件，然后把要忽略的文件名写进去，Git就会每次在提交的时候自动忽略这些文件，我们不需要从头写一个<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，所有的配置文件都可以在线浏览：<a href="https://github.com/github/gitignore。" target="_blank" rel="external">https://github.com/github/gitignore。</a><br>     有的时候，你想添加一个文件到git ，但是却发现添加不了，原因可能是这个文件被忽略了，如果想强制添加可以使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add -f &lt;filename&gt;</div></pre></td></tr></table></figure></p>
<p>还有的时候发现可能是 <code>.gitignore</code>文件写错了，需要找出来到底哪个规则写错了，可以使用命令检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git check-ignore -v &lt;filename&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>配置别名，简化命令。有时候命令太长或者单词不好记就可以使用Git来配置别名来达到高效的目的，例如将命令<code>git status</code>简化为<code>git st</code>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.st status</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意</strong>：<br><code>--global</code> 参数是全局参数，也就是这些命令在这台电脑的所有Git 仓库下都可以使用（是针对当前用户起作用），如果不加这个参数，就只能对当前仓库起作用。<br>每个仓库的配置文件都放在<code>.git/config</code> 文件中，其中别名就在 <code>[alias]</code> 后面，要想删除别名直接把对应的那行删除就行了<br>而每个用户的配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中。其中别名就在 <code>[alias]</code>后面，要想删除别名直接把对应的那行删除就行了。</p>
<h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>教程地址：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="external">廖雪峰GIt教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ovas9vc9a.bkt.clouddn.com/2017-08-27_035118.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本文档笔记是本人通过学习&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;廖雪峰Git教程&lt;/a&gt;的整理而来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本文档主要记录本人当时在学习过程中认为重要的概念和命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;创建一个版本库&quot;&gt;&lt;a href=&quot;#创建一个版本库&quot; class=&quot;headerlink&quot; title=&quot;创建一个版本库&quot;&gt;&lt;/a&gt;创建一个版本库&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mkdir learngit //使用命令创建一个目录&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cd learngit //进入这个目录&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;pwd //用于显示当前目录&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Git" scheme="http://dmego.me/categories/Git/"/>
    
    
      <category term="学习笔记" scheme="http://dmego.me/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>七里香</title>
    <link href="http://dmego.me/2017/08/24/daphne-odera.html"/>
    <id>http://dmego.me/2017/08/24/daphne-odera.html</id>
    <published>2017-08-24T01:10:00.000Z</published>
    <updated>2017-09-10T16:18:31.045Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>席慕蓉</p>
<center><br>溪水急着要流向海洋<br>浪潮却渴望重回土地<br><img src="http://ovas9vc9a.bkt.clouddn.com/blogpic/170910/e780FE15lH.png?imageslim" width="360px"><br>在绿树白花的篱前<br>曾那样轻易地挥手道别<br><a id="more"></a><br>而沧桑的二十年后<br>我们的魂魄却夜夜归来<br><br>微风拂过时<br>便化作满园的郁香<br></center></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;席慕蓉&lt;/p&gt;
&lt;center&gt;&lt;br&gt;溪水急着要流向海洋&lt;br&gt;浪潮却渴望重回土地&lt;br&gt;&lt;img src=&quot;http://ovas9vc9a.bkt.clouddn.com/blogpic/170910/e780FE15lH.png?imageslim&quot; width=&quot;360px&quot;&gt;&lt;br&gt;在绿树白花的篱前&lt;br&gt;曾那样轻易地挥手道别&lt;br&gt;
    
    </summary>
    
      <category term="情" scheme="http://dmego.me/categories/%E6%83%85/"/>
    
    
      <category term="小诗" scheme="http://dmego.me/tags/%E5%B0%8F%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>第三个巷口</title>
    <link href="http://dmego.me/2017/06/14/third-lane.html"/>
    <id>http://dmego.me/2017/06/14/third-lane.html</id>
    <published>2017-06-13T17:57:00.000Z</published>
    <updated>2017-06-13T18:49:46.837Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>木青子日</li>
</ul>
<center><br>我住的那条街道上<br>有一个流浪的南方姑娘<br>她喜欢云的白天<br>她喜欢星的黑夜<br></center><br><img src="/images/threeXianKou.jpg" width="500px" high="450px"><br><a id="more"></a><br><center><br>在北方的第六百五十六个晚上<br>雨落在第三个巷口的地方<br>南方姑娘啊<br>她悄然离开了这座城市<br>回到了桃花十里的故乡<br></center>















]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;木青子日&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;我住的那条街道上&lt;br&gt;有一个流浪的南方姑娘&lt;br&gt;她喜欢云的白天&lt;br&gt;她喜欢星的黑夜&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;/images/threeXianKou.jpg&quot; width=&quot;500px&quot; high=&quot;450px&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="情" scheme="http://dmego.me/categories/%E6%83%85/"/>
    
    
      <category term="幻觉" scheme="http://dmego.me/tags/%E5%B9%BB%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>远和近</title>
    <link href="http://dmego.me/2017/06/10/far-and-near.html"/>
    <id>http://dmego.me/2017/06/10/far-and-near.html</id>
    <published>2017-06-10T15:00:00.000Z</published>
    <updated>2017-06-13T19:06:31.126Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>作者：顾城</p>
<center><br>​     你<br>一会看我，一会看云<br>  我觉得<br></center><br><img src="/images/yuanhejin.jpg" width="450px"><br><a id="more"></a><br><center><br>你看我时很远<br>你看云时很近<br></center>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;作者：顾城&lt;/p&gt;
&lt;center&gt;&lt;br&gt;​     你&lt;br&gt;一会看我，一会看云&lt;br&gt;  我觉得&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;/images/yuanhejin.jpg&quot; width=&quot;450px&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="病" scheme="http://dmego.me/categories/%E7%97%85/"/>
    
    
      <category term="幻觉" scheme="http://dmego.me/tags/%E5%B9%BB%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>自杀者之歌</title>
    <link href="http://dmego.me/2017/06/01/song-of-suicide.html"/>
    <id>http://dmego.me/2017/06/01/song-of-suicide.html</id>
    <published>2017-05-31T20:30:00.000Z</published>
    <updated>2017-06-13T18:57:54.352Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>作者：海子<br><center><br>伏在下午的水中<br>窗帘一掀掀<br>一两根树枝伸过来<br>肉体，水面的宝石<br></center><br><img src="/images/SongofSuicide.jpg" alt=""><br><center><br>是对半分裂的瓶子<br>瓶里的水不能分裂<a id="more"></a>
伏在一具斧子上<br>像伏在一具琴上<br>还有绳索<br>盘在床底下<br>林间的太阳砍断你<br>像砍断南风<br>你把枪打开，独自走回故乡<br>像一只鸽子<br>倒在猩红的篮子上<center></center></center></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;作者：海子&lt;br&gt;&lt;center&gt;&lt;br&gt;伏在下午的水中&lt;br&gt;窗帘一掀掀&lt;br&gt;一两根树枝伸过来&lt;br&gt;肉体，水面的宝石&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;/images/SongofSuicide.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;center&gt;&lt;br&gt;是对半分裂的瓶子&lt;br&gt;瓶里的水不能分裂
    
    </summary>
    
      <category term="病" scheme="http://dmego.me/categories/%E7%97%85/"/>
    
    
      <category term="抑郁成疾" scheme="http://dmego.me/tags/%E6%8A%91%E9%83%81%E6%88%90%E7%96%BE/"/>
    
  </entry>
  
  <entry>
    <title>有些冷暖</title>
    <link href="http://dmego.me/2017/04/18/some-cold-and-warm.html"/>
    <id>http://dmego.me/2017/04/18/some-cold-and-warm.html</id>
    <published>2017-04-18T13:36:00.000Z</published>
    <updated>2017-06-13T19:01:47.627Z</updated>
    
    <content type="html"><![CDATA[<center><br>已经连续好几个星期没有好好睡一觉了<br>也许是因为最近的事儿多<br>没日没夜的忙起来，就忘记了许多闲常<br><br>人间的，四月天，天空蓝了许多<br>街头的柳絮，给人带来的不是诗情画意<br>反而弥漫着一股糟糕的情绪<br></center><br><img src="/images/diary-2017-4-16~18.jpg" alt=""><br><a id="more"></a><br><center><br>好像每个人身上带着无数的刺<br>有些偏距，但是却不像电影情节那样<br>结局并不用看导演的心情<br>跑龙套的小丑说他也会像男主角一样出名<br>也许在某一天，也许在某一年<br><br>好久没有见过那只橘黄色的肥猫了<br>有人说是因为太胖走不动了<br>也有人说是你行色太匆匆了<br></center>



]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;br&gt;已经连续好几个星期没有好好睡一觉了&lt;br&gt;也许是因为最近的事儿多&lt;br&gt;没日没夜的忙起来，就忘记了许多闲常&lt;br&gt;&lt;br&gt;人间的，四月天，天空蓝了许多&lt;br&gt;街头的柳絮，给人带来的不是诗情画意&lt;br&gt;反而弥漫着一股糟糕的情绪&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;/images/diary-2017-4-16~18.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="语" scheme="http://dmego.me/categories/%E8%AF%AD/"/>
    
    
      <category term="小冥" scheme="http://dmego.me/tags/%E5%B0%8F%E5%86%A5/"/>
    
  </entry>
  
  <entry>
    <title>也许</title>
    <link href="http://dmego.me/2016/11/20/perhaps.html"/>
    <id>http://dmego.me/2016/11/20/perhaps.html</id>
    <published>2016-11-20T02:36:00.000Z</published>
    <updated>2017-06-13T19:17:09.052Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>舒婷</li>
</ul>
<center><br>也许我们的心<br>总是没有读者<br>也许路开始已错<br>结果还是错<br>也许我们点起一个个灯笼<br>又被大风一个个吹灭<br></center><br><img src="/images/xiaoshi-yexu.jpg" width="500px" high="450px"><br><a id="more"></a><br><center><br>也许燃尽生命烛照黑暗<br>身边却没有取暖之火<br>也许泪水流尽<br>土地更加肥沃<br>也许我们歌唱太阳<br>也被太阳歌唱着<br>也许肩上越是沉重<br>信念越是巍峨<br>也许为一切苦难疾呼<br>对个人的不幸只好沉默<br><br>也许<br>由于不可抗拒的召唤<br>我们没有其它选择<br></center>

]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;舒婷&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;也许我们的心&lt;br&gt;总是没有读者&lt;br&gt;也许路开始已错&lt;br&gt;结果还是错&lt;br&gt;也许我们点起一个个灯笼&lt;br&gt;又被大风一个个吹灭&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;/images/xiaoshi-yexu.jpg&quot; width=&quot;500px&quot; high=&quot;450px&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="杂" scheme="http://dmego.me/categories/%E6%9D%82/"/>
    
    
      <category term="小诗" scheme="http://dmego.me/tags/%E5%B0%8F%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>汉诺塔的图解递归算法</title>
    <link href="http://dmego.me/2016/10/16/hanoi.html"/>
    <id>http://dmego.me/2016/10/16/hanoi.html</id>
    <published>2016-10-15T17:56:00.000Z</published>
    <updated>2017-09-30T06:32:56.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<h2 id="抽象为数学问题"><a href="#抽象为数学问题" class="headerlink" title="抽象为数学问题"></a>抽象为数学问题</h2><p>如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数<br><img src="http://upload-images.jianshu.io/upload_images/4632163-2786ae9a6ef8a3f8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="抽象为数学问题"><br>解：<br>(1)  n == 1</p>
<blockquote>
<p>​    <strong>第1次  1号盘  A—-&gt;C       sum = 1 次</strong></p>
</blockquote>
<p>(2)  n == 2</p>
<blockquote>
<p>​    第1次  1号盘  A—-&gt;B<br>​    <strong>第2次  2号盘  A—-&gt;C</strong><br>​    第3次  1号盘  B—-&gt;C        sum = 3 次</p>
</blockquote>
<p>（3）n == 3</p>
<blockquote>
<p>​    第1次  1号盘  A—-&gt;C<br>​    第2次  2号盘  A—-&gt;B<br>​    第3次  1号盘  C—-&gt;B<br>​    <strong>第4次  3号盘  A—-&gt;C</strong><br>​    第5次  1号盘  B—-&gt;A<br>​    第6次  2号盘  B—-&gt;C<br>​    第7次  1号盘  A—-&gt;C        sum = 7 次</p>
</blockquote>
<p>不难发现规律：</p>
<blockquote>
<p>​    1个圆盘的次数 2的1次方减1<br>​    2个圆盘的次数 2的2次方减1<br>​    3个圆盘的次数 2的3次方减1<br>​     。  。   。    。   。<br>​    n个圆盘的次数 2的n次方减1</p>
</blockquote>
<p> 故：移动次数为：2^n - 1</p>
<p>##调用方法的栈机制（特点：先进后出）<br>从主线程开始调用方法（函数）进行不停的压栈和出栈操作，函数的调用就是将函数压如栈中，函数的结束就是函数出栈的过程，这样就保证了方法调用的顺序流，即当函数出现多层嵌套时，需要从外到内一层层把函数压入栈中，最后栈顶的函数先执行结束（最内层的函数先执行结束）后出栈，再倒数第二层的函数执行结束出栈，到最后，第一个进栈的函数调用结束后从栈中弹出回到主线程，并且结束。</p>
<h2 id="算法分析（递归算法）"><a href="#算法分析（递归算法）" class="headerlink" title="算法分析（递归算法）"></a>算法分析（递归算法）</h2><p>我们在利用计算机求汉诺塔问题时，必不可少的一步是对整个实现求解进行算法分析。到目前为止，求解汉诺塔问题最简单的算法还是同过递归来求，至于是什么是递归，递归实现的机制是什么，我们说的简单点就是自己是一个方法或者说是函数，但是在自己这个函数里有调用自己这个函数的语句，而这个调用怎么才能调用结束呢？，这里还必须有一个结束点，或者具体的说是在调用到某一次后函数能返回一个确定的值，接着倒数第二个就能返回一个确定的值，一直到第一次调用的这个函数能返回一个确定的值。<br>  实现这个算法可以简单分为三个步骤：</p>
<blockquote>
<p>（1）     把n-1个盘子由A 移到 B；<br>（2）     把第n个盘子由 A移到 C；<br>（3）     把n-1个盘子由B 移到 C；</p>
</blockquote>
<p>从这里入手，在加上上面数学问题解法的分析，我们不难发现，移到的步数必定为奇数步：</p>
<blockquote>
<p>（1）中间的一步是把最大的一个盘子由A移到C上去；<br>（2）中间一步之上可以看成把A上n-1个盘子通过借助辅助塔（C塔）移到了B上，<br>（3）中间一步之下可以看成把B上n-1个盘子通过借助辅助塔（A塔）移到了C上；</p>
<h2 id="java源代码"><a href="#java源代码" class="headerlink" title="java源代码"></a>java源代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> demo;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 目的：实现汉诺塔问题求解</div><div class="line"> * 作者：Dmego  时间：2016-10-15</div><div class="line"> */</div><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TowersOfHanoi</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m =<span class="number">0</span>;<span class="comment">//标记移动次数</span></div><div class="line">    <span class="comment">//实现移动的函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> disks,<span class="keyword">char</span> N,<span class="keyword">char</span> M)</span></span></div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"第"</span> + (++m) +<span class="string">" 次移动 : "</span> +<span class="string">" 把 "</span>+ disks+<span class="string">" 号圆盘从 "</span> + N +<span class="string">" -&gt;移到-&gt;  "</span> + M);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//递归实现汉诺塔的函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> A,<span class="keyword">char</span> B,<span class="keyword">char</span> C)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="comment">//圆盘只有一个时，只需将其从A塔移到C塔</span></div><div class="line">            TowersOfHanoi.move(<span class="number">1</span>, A, C);<span class="comment">//将编b号为1的圆盘从A移到C</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;<span class="comment">//否则</span></div><div class="line">            hanoi(n - <span class="number">1</span>, A, C, B);<span class="comment">//递归，把A塔上编号1~n-1的圆盘移到B上，以C为辅助塔</span></div><div class="line">            TowersOfHanoi.move(n, A, C);<span class="comment">//把A塔上编号为n的圆盘移到C上</span></div><div class="line">            hanoi(n - <span class="number">1</span>, B, A, C);<span class="comment">//递归，把B塔上编号1~n-1的圆盘移到C上，以A为辅助塔</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Scanner imput = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">char</span> A = <span class="string">'A'</span>;</div><div class="line">        <span class="keyword">char</span> B = <span class="string">'B'</span>;</div><div class="line">        <span class="keyword">char</span> C = <span class="string">'C'</span>;</div><div class="line">        System.out.println(<span class="string">"******************************************************************************************"</span>);</div><div class="line">        System.out.println(<span class="string">"这是汉诺塔问题（把A塔上编号从小号到大号的圆盘从A塔通过B辅助塔移动到C塔上去"</span>);</div><div class="line">        System.out.println(<span class="string">"******************************************************************************************"</span>);</div><div class="line">        System.out.print(<span class="string">"请输入圆盘的个数："</span>);</div><div class="line">        <span class="keyword">int</span> disks = imput.nextInt();</div><div class="line">        TowersOfHanoi.hanoi(disks, A, B, C);</div><div class="line">        System.out.println(<span class="string">"&gt;&gt;移动了"</span> + m + <span class="string">"次，把A上的圆盘都移动到了C上"</span>);</div><div class="line">        imput.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="图解程序运行流程"><a href="#图解程序运行流程" class="headerlink" title="图解程序运行流程"></a>图解程序运行流程</h2><blockquote>
<p>（1）函数hanoi(int n,char A,char B,char C)的功能是把编号为n的圆盘借助B从A移动到 C上。<br>（2）函数move(int n ,char N ,char M)的功能是把1编号为n的圆盘从N 移到M上</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/4632163-80c543b7b1ddf391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图解程序运行流程"></p>
<h2 id="程序运行截图"><a href="#程序运行截图" class="headerlink" title="程序运行截图"></a>程序运行截图</h2><p><img src="http://upload-images.jianshu.io/upload_images/4632163-fd664f24a7dd338a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="程序运行截图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h2&gt;&lt;p&gt;汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://dmego.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="汉诺塔" scheme="http://dmego.me/tags/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    
      <category term="递归" scheme="http://dmego.me/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
